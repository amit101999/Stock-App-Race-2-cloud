'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateServeCommand = exports.slateUtils = void 0;
const ansi_colors_1 = require("ansi-colors");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const archiver_1 = __importDefault(require("./archiver"));
const error_1 = __importDefault(require("./error"));
const runtime_store_1 = __importDefault(require("./runtime-store"));
const fs_1 = require("./util_modules/fs");
const option_1 = require("./util_modules/option");
const constants_1 = require("./util_modules/constants");
const logger_1 = require("./util_modules/logger");
const minimatch_1 = __importDefault(require("minimatch"));
const env_1 = require("./util_modules/env");
const async_1 = require("./util_modules/fs/lib/async");
exports.slateUtils = {
    validate: (source) => __awaiter(void 0, void 0, void 0, function* () {
        const sourceDirExists = yield fs_1.ASYNC.dirExists(source);
        if (!sourceDirExists) {
            throw new error_1.default('source directory does not exist', {
                exit: 1,
                errorId: 'SLATE-UTILS-1',
                arg: [ansi_colors_1.italic.red(source)]
            });
        }
    }),
    getSlateFilters(targetStr) {
        return targetStr.split(',').reduce((filterArr, target) => {
            const opts = target.split(':');
            if (opts[0] === 'slate' && opts[1]) {
                filterArr.push(opts[1]);
                return filterArr;
            }
            return filterArr;
        }, []);
    },
    filterTargets(allTargets) {
        const only = (0, option_1.getOptionValue)('only');
        if (only !== undefined) {
            const onlyTargs = this.getSlateFilters(only);
            if (onlyTargs.length === 0) {
                return allTargets;
            }
            const refined = onlyTargs.reduce((filtered, filter) => {
                const targDetailsIdx = allTargets.findIndex((targ) => targ.name === filter);
                if (targDetailsIdx === -1) {
                    filtered.unmatched.push(filter);
                }
                else {
                    const targDetails = allTargets.splice(targDetailsIdx, 1);
                    filtered.matched.push(targDetails[0]);
                }
                return filtered;
            }, {
                matched: [],
                unmatched: []
            });
            if (refined.unmatched.length > 0) {
                throw new error_1.default(`The filters ${(0, ansi_colors_1.bold)(refined.unmatched.join(', '))} provided with --only option does not match with any Slate service in ${constants_1.FILENAME.config}.`);
            }
            return refined.matched;
        }
        const except = (0, option_1.getOptionValue)('except');
        if (except !== undefined) {
            const exceptTargs = this.getSlateFilters(except);
            const refined = exceptTargs.reduce((filtered, filter) => {
                const targDetailsIdx = allTargets.findIndex((targ) => targ.name === filter);
                if (targDetailsIdx === -1) {
                    filtered.unmatched.push(filter);
                }
                else {
                    filtered.matched.splice(targDetailsIdx, 1);
                }
                return filtered;
            }, {
                matched: allTargets,
                unmatched: []
            });
            if (refined.unmatched.length > 0) {
                (0, logger_1.message)(`The filters ${(0, ansi_colors_1.bold)(refined.unmatched.join(', '))} provided with --except option does not match with any Slate service in ${constants_1.FILENAME.config}, hence ignored.`);
            }
            return refined.matched;
        }
        const refinedTargets = allTargets.filter((app) => app.source.includes(runtime_store_1.default.get('cwd')));
        if (refinedTargets.length === 0 || !refinedTargets) {
            throw new error_1.default('You are not in a catalyst app directory.');
        }
        return refinedTargets;
    },
    pack: (source) => __awaiter(void 0, void 0, void 0, function* () {
        if (env_1.isCI) {
            source = source !== null && source !== void 0 ? source : runtime_store_1.default.get('cwd');
            const tempDir = (0, path_1.resolve)(constants_1.FOLDERNAME.slate);
            if (!(yield (0, async_1.dirExists)(tempDir))) {
                (0, fs_extra_1.mkdir)(tempDir);
                const excludePatterns = [
                    '**/.catalyst',
                    `**/${constants_1.FILENAME.log}`,
                    `**/${constants_1.FILENAME.config}`,
                    `**/${constants_1.FILENAME.rc}`,
                    `**/${constants_1.FILENAME.app_config}`,
                    `**/${constants_1.FILENAME.catalyst_ignore}`
                ];
                const files = yield fs_1.ASYNC.walk(source, {
                    filter: {
                        exclude: (path) => __awaiter(void 0, void 0, void 0, function* () {
                            return !!excludePatterns.find((glob) => (0, minimatch_1.default)(path.replace(source + path_1.sep, ''), glob, {
                                dot: true
                            }));
                        }),
                        excludeDir: true
                    }
                });
                const zip = new archiver_1.default('static');
                const fileArr = [];
                files.forEach((file) => {
                    fileArr.push({
                        path: (0, path_1.relative)(source, file.path),
                        type: (0, path_1.extname)(file.path).replace('.', '').toUpperCase() || '',
                        size: file.stats.size
                    });
                    zip.add(file.path.replace(source + path_1.sep, ''), file.stats.isSymbolicLink()
                        ? fs_1.SYNC.readSymLink(file.path)
                        : fs_1.SYNC.getReadStream(file.path), {
                        mode: file.stats.mode
                    });
                });
                const zipFinalizer = yield zip.finalize();
                const staticZip = (0, path_1.join)(tempDir, constants_1.FILENAME.slate.static_zip);
                yield zipFinalizer.writeZip(staticZip);
                const content = {
                    version: '',
                    framework: process.env.ZC_FRAMEWORK,
                    runtime: '',
                    static: fileArr
                };
                const configJson = (0, path_1.join)(tempDir, constants_1.FILENAME.slate.config_json);
                fs_1.SYNC.writeFile(configJson, JSON.stringify(content, null, 2) + '\n');
            }
            const slateZip = yield fs_1.ASYNC.walk(tempDir, { includeDirPaths: false });
            const zipWithJson = new archiver_1.default();
            slateZip.forEach((file) => {
                zipWithJson.add(file.path.replace(tempDir + path_1.sep, ''), file.stats.isSymbolicLink()
                    ? fs_1.SYNC.readSymLink(file.path)
                    : fs_1.SYNC.getReadStream(file.path), {
                    mode: file.stats.mode
                });
            });
            const zipFinalizerWithJson = yield zipWithJson.finalize();
            yield fs_1.ASYNC.deleteDir(tempDir);
            return yield zipFinalizerWithJson.fsStream();
        }
        const excludePatterns = [
            '**/.DS_Store',
            '**/.catalyst',
            '**/.vscode/**/*',
            '**/node_modules',
            `**/${constants_1.FILENAME.log}`,
            `**/${constants_1.FILENAME.config}`,
            `**/${constants_1.FILENAME.rc}`,
            `**/${constants_1.FILENAME.app_config}`,
            `**/${constants_1.FILENAME.catalyst_ignore}`
        ];
        const slateZip = yield fs_1.ASYNC.walk(source, {
            filter: {
                exclude: (path) => __awaiter(void 0, void 0, void 0, function* () {
                    return !!excludePatterns.find((glob) => (0, minimatch_1.default)(path.replace(source + path_1.sep, ''), glob, { dot: true }));
                }),
                excludeDir: true
            }
        });
        const zipWithJson = new archiver_1.default();
        slateZip.forEach((file) => {
            zipWithJson.add(file.path.replace(source + path_1.sep, ''), file.stats.isSymbolicLink()
                ? fs_1.SYNC.readSymLink(file.path)
                : fs_1.SYNC.getReadStream(file.path), {
                mode: file.stats.mode
            });
        });
        const zipFinalizerWithJson = yield zipWithJson.finalize();
        return yield zipFinalizerWithJson.fsStream();
    })
};
function validateServeCommand(targDetails) {
    targDetails.forEach((targ) => {
        var _a, _b, _c;
        if (((_a = targ.config) === null || _a === void 0 ? void 0 : _a.framework) !== 'static') {
            const serveConfig = fs_1.SYNC.readJSONFile((0, path_1.join)(targ.source, constants_1.FILENAME.cli_config));
            if (targ.validity.valid && !((_b = serveConfig === null || serveConfig === void 0 ? void 0 : serveConfig.slate) === null || _b === void 0 ? void 0 : _b.dev_command)) {
                targ.validity = {
                    valid: false,
                    reason: 'Development command missing'
                };
            }
            if (!((_c = serveConfig === null || serveConfig === void 0 ? void 0 : serveConfig.slate) === null || _c === void 0 ? void 0 : _c.dev_command).includes('ZC_SLATE_PORT')) {
                targ.validity = {
                    valid: false,
                    reason: `Port configuration is missing. Please set the ${(0, ansi_colors_1.bold)('ZC_SLATE_PORT')} as the port value in ${(0, ansi_colors_1.bold)('cli-config.json')} under your development command.`
                };
            }
        }
    });
    return targDetails;
}
exports.validateServeCommand = validateServeCommand;
