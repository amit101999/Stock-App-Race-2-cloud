'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ansi_colors_1 = require("ansi-colors");
const integ_1 = require("../../../fn-utils/lib/integ");
const prompt_1 = __importDefault(require("../../../prompt"));
const runtime_store_1 = __importDefault(require("../../../runtime-store"));
const constants_1 = require("../../../util_modules/constants");
const fs_1 = require("../../../util_modules/fs");
const index_1 = require("../../../util_modules/logger/index");
const option_1 = require("../../../util_modules/option");
const common_1 = require("../../util/common");
const languages_1 = __importDefault(require("./languages"));
const catalyst_details_1 = __importDefault(require("../../../endpoints/lib/catalyst-details"));
const path_1 = require("path");
const signals_1 = require("../../../signals");
const config_1 = require("../../../util_modules/config");
const cliq_1 = __importDefault(require("../../../event_generate/integration/cliq"));
const error_1 = __importDefault(require("../../../error"));
exports.default = () => __awaiter(void 0, void 0, void 0, function* () {
    const currentCmd = (0, option_1.getCurrentCommand)();
    const functionsDirPath = config_1.functionsConfig.source();
    const catalystDetailsAPI = new catalyst_details_1.default();
    const integServicesPromise = catalystDetailsAPI
        .getDetails('integration_services')
        .catch((err) => (0, index_1.debug)('Error feting integ services: ', err));
    runtime_store_1.default.set('context.functions.dir_path', functionsDirPath);
    if (currentCmd === 'init' || currentCmd === 'functions:setup') {
        (0, index_1.message)('A directory ' +
            ansi_colors_1.cyan.bold(constants_1.FOLDERNAME.functions) +
            ' will be created with a catalyst function pre-configured.\n');
        const folderExits = yield fs_1.ASYNC.dirExists(functionsDirPath);
        const overwriteAns = folderExits
            ? yield prompt_1.default.ask(prompt_1.default.question('overwrite', 'Directory ' +
                (0, ansi_colors_1.underline)(constants_1.FOLDERNAME.functions) +
                ' already exists. Overwrite ?', {
                type: 'confirm',
                defaultAns: false
            }))
            : { overwrite: true };
        if (!overwriteAns.overwrite) {
            (0, index_1.warning)('skipping function setup');
            return;
        }
        yield fs_1.ASYNC.deleteDir(functionsDirPath).catch();
    }
    const fnTypeChoices = [
        prompt_1.default.choice('BasicIO', {
            value: constants_1.FN_TYPE.basic,
            short: 'basicIO'
        }),
        prompt_1.default.choice('AdvancedIO', {
            value: constants_1.FN_TYPE.advanced,
            short: 'advancedIO'
        }),
        prompt_1.default.choice('Event', {
            value: constants_1.FN_TYPE.event,
            short: 'event'
        }),
        prompt_1.default.choice('Cron', {
            value: constants_1.FN_TYPE.cron,
            short: 'cron'
        }),
        prompt_1.default.choice('Browser Logic', {
            id: 'browser_logic',
            value: constants_1.FN_TYPE.browserLogic,
            short: 'browser logic'
        }),
        prompt_1.default.choice('Job', {
            value: constants_1.FN_TYPE.job,
            short: 'job'
        })
    ];
    const integServicesRes = yield integServicesPromise;
    const integServices = integServicesRes === null || integServicesRes === void 0 ? void 0 : integServicesRes.integration_services;
    if (integServices && integServices.length > 0) {
        fnTypeChoices.push(prompt_1.default.choice('Integration', {
            value: constants_1.FN_TYPE.integration,
            short: 'integration'
        }));
    }
    const fnTypeAns = yield prompt_1.default.ask(prompt_1.default.question('type', 'Which type of function do you like to create?', {
        type: 'list',
        choices: fnTypeChoices
    }));
    runtime_store_1.default.set('context.functions.type', fnTypeAns.type);
    if (fnTypeAns.type === constants_1.FN_TYPE.integration && integServices) {
        yield (0, integ_1.integHelper)(integServices);
    }
    const runtimeAns = yield (0, common_1.getRuntimePromptAnswer)('Which runtime do you prefer to write your function?', fnTypeAns.type);
    const targetPath = yield languages_1.default[runtimeAns.lang](runtimeAns.runtime)();
    if (!targetPath) {
        return;
    }
    const inputsJson = {};
    switch (fnTypeAns.type) {
        case constants_1.FN_TYPE.cron: {
            inputsJson.test_cron_input = {
                test_param: 'test_value'
            };
            break;
        }
        case constants_1.FN_TYPE.event: {
            const jsonContent = yield (0, signals_1.generate)('cache', 'cache_item_created');
            inputsJson.test_event_cache_put = jsonContent;
            break;
        }
        case constants_1.FN_TYPE.job: {
            inputsJson.test_job = {
                params: {
                    key: 'value'
                }
            };
            break;
        }
        case constants_1.FN_TYPE.integration: {
            const _integService = runtime_store_1.default.get('context.functions.integration.service');
            if (_integService === 'ZohoCliq') {
                const cliqData = yield (0, cliq_1.default)('bot,welcome_handler');
                if (!cliqData) {
                    throw new error_1.default('Invalid input data generate for cliq integration function', { exit: 2 });
                }
                inputsJson.bot_welcome_handler = JSON.parse(cliqData);
            }
            else {
                inputsJson.convokraft_test_input = {
                    todo: 'welcome'
                };
            }
            break;
        }
        default:
            return;
    }
    return Object.keys(inputsJson).length
        ? fs_1.ASYNC.writeJSONFile((0, path_1.join)(targetPath, constants_1.FILENAME.catalyst_inputs), inputsJson, {
            spaces: 2
        })
        : Promise.resolve();
});
