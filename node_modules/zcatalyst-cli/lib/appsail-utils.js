"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAppSail = exports.filterTargets = void 0;
const ansi_colors_1 = require("ansi-colors");
const error_1 = __importDefault(require("./error"));
const appsail_1 = require("./util_modules/config/lib/appsail");
const constants_1 = require("./util_modules/constants");
const index_1 = require("./util_modules/logger/index");
const option_1 = require("./util_modules/option");
const container_1 = require("./util_modules/container");
const image_1 = require("@zcatalyst/container-plugin/out/endpoints/image");
const fs_1 = require("./util_modules/fs");
const util_1 = require("util");
function getAppSailFilters(targetStr) {
    return targetStr.split(',').reduce((filterArr, target) => {
        const opts = target.split(':');
        if (opts[0] === 'appsail' && opts[1]) {
            filterArr.push(opts[1]);
            return filterArr;
        }
        return filterArr;
    }, []);
}
function filterTargets(allTargets) {
    const only = (0, option_1.getOptionValue)('only');
    if (only !== undefined) {
        const onlyTargs = getAppSailFilters(only);
        if (onlyTargs.length === 0) {
            return allTargets;
        }
        const refined = onlyTargs.reduce((filtered, filter) => {
            const targDetailsIdx = allTargets.findIndex((targ) => targ.name === filter);
            if (targDetailsIdx === -1) {
                filtered.unmatched.push(filter);
            }
            else {
                const targDetails = allTargets.splice(targDetailsIdx, 1);
                filtered.matched.push(targDetails[0]);
            }
            return filtered;
        }, {
            matched: [],
            unmatched: []
        });
        if (refined.unmatched.length > 0) {
            throw new error_1.default(`The filters ${(0, ansi_colors_1.bold)(refined.unmatched.join(', '))} provided with --only option does not match with any AppSail in ${constants_1.FILENAME.config}.`, { exit: 1 });
        }
        return refined.matched;
    }
    const except = (0, option_1.getOptionValue)('except');
    if (except !== undefined) {
        const exceptTargs = getAppSailFilters(except);
        const refined = exceptTargs.reduce((filtered, filter) => {
            const targDetailsIdx = allTargets.findIndex((targ) => targ.name === filter);
            if (targDetailsIdx === -1) {
                filtered.unmatched.push(filter);
            }
            else {
                filtered.matched.splice(targDetailsIdx, 1);
            }
            return filtered;
        }, {
            matched: allTargets,
            unmatched: []
        });
        if (refined.unmatched.length > 0) {
            (0, index_1.message)(`The filters ${(0, ansi_colors_1.bold)(refined.unmatched.join(', '))} provided with --except option does not match with any AppSail in ${constants_1.FILENAME.config}, hence ignored.`);
        }
        return refined.matched;
    }
    return allTargets;
}
exports.filterTargets = filterTargets;
function validateAppSail(targDetails) {
    return __awaiter(this, void 0, void 0, function* () {
        let isSocket;
        const getImageInfo = (target) => __awaiter(this, void 0, void 0, function* () {
            switch (true) {
                case target.source.startsWith(appsail_1.CONTAINER_IMAGE_PROTOCOLS.docker): {
                    const imgTag = target.source.replace(appsail_1.CONTAINER_IMAGE_PROTOCOLS.docker, '');
                    return (0, image_1.inspectImage)(imgTag);
                }
                case target.source.startsWith(appsail_1.CONTAINER_IMAGE_PROTOCOLS.dockerArchive): {
                    const imgTar = target.source.replace(appsail_1.CONTAINER_IMAGE_PROTOCOLS.dockerArchive, '');
                    const isFile = yield fs_1.ASYNC.fileExists(imgTar);
                    if (!isFile) {
                        throw new error_1.default('Invalid image tar path: ' + imgTar, { exit: 1 });
                    }
                    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                        var _a;
                        try {
                            const manifestJsonStream = yield (0, image_1.getTarEntry)(imgTar, 'manifest.json');
                            if (!manifestJsonStream) {
                                throw new error_1.default('Corrupted image tar :: manifest.json not found in the tar', { exit: 1 });
                            }
                            const manifestJson = yield fs_1.ASYNC.readStreamAsJSON(manifestJsonStream);
                            const config = (_a = manifestJson.at(0)) === null || _a === void 0 ? void 0 : _a.Config;
                            if (!config) {
                                throw new error_1.default('Corrupted image tar :: invalid manifest.json file. Unable to identify the config file', { exit: 1 });
                            }
                            const configFileStream = yield (0, image_1.getTarEntry)(imgTar, config);
                            if (!configFileStream) {
                                throw new error_1.default(`Corrupted image tar :: config file ${config} not found in the tar`, { exit: 1 });
                            }
                            const configFile = yield fs_1.ASYNC.readStreamAsJSON(configFileStream);
                            resolve(configFile);
                        }
                        catch (er) {
                            er instanceof error_1.default
                                ? reject(er)
                                : reject(error_1.default.getErrorInstance(er));
                        }
                    }));
                }
                default: {
                    throw new error_1.default('Unsupported image source: ' + target.source, { exit: 1 });
                }
            }
        });
        const _details = targDetails.map((targ) => __awaiter(this, void 0, void 0, function* () {
            var _b, _c;
            if (targ.validity.valid) {
                if (targ.runtime === 'custom') {
                    if (isSocket === undefined) {
                        isSocket = yield (0, container_1.isSocketAccessible)(false);
                    }
                    if (isSocket === false) {
                        targ.validity = {
                            valid: false,
                            reason: 'ZCatalyst-CLI is unable to communicate with the Container runtime'
                        };
                        return targ;
                    }
                    try {
                        const imgInfo = (yield getImageInfo(targ));
                        const os = 'os' in imgInfo ? imgInfo.os : imgInfo.Os;
                        if ((os === null || os === void 0 ? void 0 : os.toLowerCase()) !== 'linux') {
                            targ.validity = {
                                valid: false,
                                reason: 'container image should be Linux based'
                            };
                            return targ;
                        }
                        const arch = 'architecture' in imgInfo
                            ? imgInfo.architecture
                            : imgInfo.Architecture;
                        if ((arch === null || arch === void 0 ? void 0 : arch.toLowerCase()) !== 'amd64') {
                            targ.validity = {
                                valid: false,
                                reason: 'container image should be amd64 based'
                            };
                            return targ;
                        }
                    }
                    catch (er) {
                        targ.validity = {
                            valid: false,
                            reason: er instanceof error_1.default ? er.message : (0, util_1.inspect)(er)
                        };
                    }
                    return targ;
                }
                if (((_b = targ.config) === null || _b === void 0 ? void 0 : _b.platform) !== 'war' && !((_c = targ.config) === null || _c === void 0 ? void 0 : _c.command)) {
                    targ.validity = {
                        valid: false,
                        reason: 'Start-up command missing'
                    };
                    return targ;
                }
            }
            return targ;
        }));
        return Promise.all(_details);
    });
}
exports.validateAppSail = validateAppSail;
