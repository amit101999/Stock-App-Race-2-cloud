"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const command_js_1 = __importDefault(require("../../internal/command.js"));
const default_js_1 = __importDefault(require("../../util_modules/constants/lib/default.js"));
const scopes_js_1 = __importDefault(require("../../authentication/constants/scopes.js"));
const option_js_1 = require("../../util_modules/option.js");
const runtime_store_js_1 = __importDefault(require("../../runtime-store.js"));
const FUNCTIONS_CONFIG = __importStar(require("../../util_modules/config/lib/functions.js"));
const index_js_1 = __importDefault(require("../../prompt/index.js"));
const index_js_2 = __importDefault(require("../../error/index.js"));
const common_js_1 = require("../../fn-utils/lib/common.js");
const index_js_3 = require("../../util_modules/constants/index.js");
const path_1 = require("path");
const ansi_colors_1 = require("ansi-colors");
const async_js_1 = require("../../util_modules/fs/lib/async.js");
const index_js_4 = __importDefault(require("../../execute/index.js"));
const project_js_1 = require("../../util_modules/project.js");
function getInputs(exeTarget) {
    return __awaiter(this, void 0, void 0, function* () {
        const inputsFile = (0, path_1.resolve)(exeTarget.source, typeof exeTarget.inputs === 'string' ? exeTarget.inputs : index_js_3.FILENAME.catalyst_inputs);
        const projectRoot = (0, project_js_1.getProjectRoot)();
        if (!inputsFile.startsWith(projectRoot)) {
            throw new index_js_2.default(`Input file path ${exeTarget.inputs} is outside the project directory.`, {
                exit: 1,
                context: {
                    resolvePath: inputsFile,
                    targetSource: projectRoot,
                    inputs: exeTarget.inputs
                }
            });
        }
        const targetInputs = yield (0, async_js_1.readJSONFile)(inputsFile).catch((err) => {
            throw new index_js_2.default('Unable to read the inputs file', {
                original: err,
                exit: 1,
                errorId: 'FEXE-2',
                arg: [(0, ansi_colors_1.italic)(inputsFile), ansi_colors_1.italic.red(err || '')]
            });
        });
        if (!targetInputs || Object.keys(targetInputs).length === 0) {
            throw new index_js_2.default('Empty inputs', {
                exit: 0,
                errorId: 'FEXE-3',
                arg: [
                    (0, ansi_colors_1.bold)(index_js_3.FILENAME.catalyst_inputs),
                    (0, ansi_colors_1.bold)(index_js_3.FILENAME.catalyst_config),
                    (0, ansi_colors_1.bold)('execution.test_inputs')
                ]
            });
        }
        const inputKeys = Object.keys(targetInputs);
        const keyOpt = (0, option_js_1.getOptionValue)('key', undefined);
        if (keyOpt && !(keyOpt in targetInputs)) {
            throw new index_js_2.default('Key not present in inputs', {
                exit: 0,
                errorId: 'FEXE-4',
                arg: [
                    ansi_colors_1.bold.italic('--key ' + (0, ansi_colors_1.red)(keyOpt)),
                    (0, ansi_colors_1.bold)(inputKeys.map((key) => '* ' + key).join('\n'))
                ]
            });
        }
        const selectedKey = yield index_js_1.default.ask(index_js_1.default.question('key', 'Please select the input', {
            type: 'list',
            choices: inputKeys.map((key) => index_js_1.default.choice(key, { value: key, short: key })),
            when: !keyOpt && inputKeys.length > 1
        }));
        return inputKeys.length === 1
            ? targetInputs[inputKeys[0]]
            : targetInputs[selectedKey.key] || targetInputs[keyOpt];
    });
}
exports.default = new command_js_1.default('functions:execute')
    .argument('[function_name]', 'Name of the function to execute')
    .argument('[data]', 'Input data for the function', '')
    .description('Execute the Non-Http functions')
    .option('--key <input_key>', 'Specify the input to be provided incase of multiple inputs present')
    .option('--debug [port]', 'the functions are invoked from local environment enabling debugging options on provided port.' +
    `(default: ${default_js_1.default.serve_port.debug.basicio})`)
    .option('--ignore-scripts', 'ignore teh pre and post lifecycle scripts')
    .needs('auth', [scopes_js_1.default.functions, scopes_js_1.default.functions_execution])
    .needs('config')
    .needs('rc')
    .action((functionName, data) => __awaiter(void 0, void 0, void 0, function* () {
    const fnSource = FUNCTIONS_CONFIG.source();
    const rawFnTargets = FUNCTIONS_CONFIG.targets();
    if (!rawFnTargets || rawFnTargets.length === 0) {
        throw new index_js_2.default('No functions linked with the catalyst directory', {
            exit: 1
        });
    }
    if (functionName && !rawFnTargets.includes(functionName)) {
        throw new index_js_2.default(`Function "${functionName}" not found in the list of functions linked to the current catalyst directory`, {
            exit: 1
        });
    }
    const fnTargets = yield (0, common_js_1.refineTargets)(functionName
        ? [(0, path_1.join)(fnSource, functionName)]
        : rawFnTargets.map((target) => (0, path_1.join)(fnSource, target)));
    if (!fnTargets || fnTargets.length === 0) {
        throw new index_js_2.default('No Valid Non-HTTP functions to execute', {
            exit: 1
        });
    }
    const exeTypes = [
        index_js_3.FN_TYPE.cron,
        index_js_3.FN_TYPE.event,
        index_js_3.FN_TYPE.integration,
        index_js_3.FN_TYPE.job
    ];
    const targetChoice = yield index_js_1.default.ask(index_js_1.default.question('fn', 'Select the function to execute', {
        type: 'list',
        choices: fnTargets.reduce((choiceArr, fn) => {
            if (fn.type && exeTypes.includes(fn.type)) {
                choiceArr.push(index_js_1.default.choice(`${(0, ansi_colors_1.bold)(fn.name)} -- ${index_js_3.REMOTE_REF.functions.type[fn.type]} -- ${fn.stack}`, {
                    value: fn,
                    short: fn.name
                }));
            }
            return choiceArr;
        }, []),
        when: fnTargets.length > 1
    }));
    const exeTarget = targetChoice.fn || fnTargets[0];
    if (!exeTarget.valid) {
        throw new index_js_2.default('The function is invalid. Reason: ' + exeTarget.failure_reason);
    }
    if (!exeTypes.includes(exeTarget.type)) {
        throw new index_js_2.default('Unsupported fn type', {
            errorId: 'FEXE-1',
            exit: 1,
            arg: [
                (0, ansi_colors_1.bold)('catalyst functions:execute'),
                (0, ansi_colors_1.red)(exeTarget.type ? index_js_3.REMOTE_REF.functions.type[exeTarget.type] : 'Unknown'),
                ansi_colors_1.bold.red(exeTarget.name),
                (0, ansi_colors_1.bold)(exeTypes
                    .map((fnType) => '* ' +
                    index_js_3.REMOTE_REF.functions.type[fnType])
                    .join('\n'))
            ]
        });
    }
    let jsonData;
    try {
        jsonData = data ? JSON.parse(data) : undefined;
    }
    catch (er) {
        throw new index_js_2.default('Error parsing the JSON input', {
            exit: 1,
            errorId: 'FEXE-6',
            arg: [ansi_colors_1.italic.red(data || '<empty-string>')]
        });
    }
    const fnInput = jsonData || (yield getInputs(exeTarget));
    if (!fnInput || typeof fnInput !== 'object') {
        throw new index_js_2.default('Invalid input', {
            exit: 1,
            errorId: 'FEXE-5',
            arg: [ansi_colors_1.bold.red(fnInput || '')]
        });
    }
    const debugPort = (0, option_js_1.getOptionValue)('debug', false);
    if (debugPort && typeof debugPort !== 'boolean') {
        runtime_store_js_1.default.set(`context.port.debug.${exeTarget.type}.${exeTarget.name}`, debugPort);
    }
    yield (0, index_js_4.default)(exeTarget, fnInput);
}));
