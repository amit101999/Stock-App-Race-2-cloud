"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ansi_colors_1 = require("ansi-colors");
const command_1 = __importDefault(require("../../internal/command"));
const runtime_store_1 = __importDefault(require("../../runtime-store"));
const constants_1 = require("../../util_modules/constants");
const logger_1 = require("../../util_modules/logger");
const option_1 = require("../../util_modules/option");
const prompt_1 = __importDefault(require("../../prompt"));
const config_1 = require("../../util_modules/config");
const fs_1 = require("../../util_modules/fs");
const error_1 = __importDefault(require("../../error"));
const path_1 = require("path");
exports.default = new command_1.default('slate:unlink')
    .description('Removes the linked Slate configuration from the local app')
    .option('--name <app_name>', 'Please provide name for your slate app')
    .needs('auth')
    .needs('config')
    .needs('rc')
    .action(() => __awaiter(void 0, void 0, void 0, function* () {
    const config = runtime_store_1.default.get('config');
    let appName = (0, option_1.getOptionValue)('name', undefined);
    const slateServices = config_1.slateConfig.raw();
    if ((slateServices === null || slateServices === void 0 ? void 0 : slateServices.length) === 0 || !slateServices) {
        throw new error_1.default('No slates found.', {
            exit: 1,
            errorId: 'SLULK-1',
            arg: [(0, ansi_colors_1.bold)('catalyst slate:link')]
        });
    }
    if (!appName) {
        const { name } = yield prompt_1.default.ask(prompt_1.default.question('name', 'Please select the slate app you want to delete', {
            type: 'list',
            choices: slateServices
        }));
        appName = name;
    }
    const slateDetails = slateServices.find((slate) => slate.name === appName);
    if (!slateDetails) {
        throw new error_1.default(`No slates match the given name ${appName}.`, {
            exit: 1,
            errorId: 'SLULK-2',
            arg: [(0, ansi_colors_1.bold)('catalyst slate:unlink')]
        });
    }
    const { removeSource } = yield prompt_1.default.ask(prompt_1.default.question('removeSource', `Do you want to delete the source?`, {
        type: 'confirm',
        default: false
    }));
    yield fs_1.ASYNC.deleteDir((0, path_1.join)(slateDetails.source, constants_1.FILENAME.cli_config));
    if (removeSource) {
        yield fs_1.ASYNC.deleteDir(slateDetails.source);
    }
    else {
        yield fs_1.ASYNC.deleteDir((0, path_1.join)(slateDetails.source, '.catalyst'));
    }
    config.unset('slate');
    config.set('slate', slateServices.filter((slateCon) => slateCon.name !== appName));
    yield config.save();
    (0, logger_1.message)((0, ansi_colors_1.bold)(constants_1.FILENAME.config) + ' file has been updated.');
    (0, logger_1.info)();
    (0, logger_1.success)('Slate unlinked successfully');
}));
