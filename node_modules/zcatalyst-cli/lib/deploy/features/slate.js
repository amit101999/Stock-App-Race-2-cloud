'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.slateLogger = exports.getEnvironmentType = void 0;
const slate_utils_1 = require("../../slate-utils");
const endpoints_1 = require("../../endpoints");
const runtime_store_1 = __importDefault(require("../../runtime-store"));
const error_1 = __importDefault(require("../../error"));
const config_1 = require("../../util_modules/config");
const throbber_1 = __importDefault(require("../../throbber"));
const logger_1 = require("../../util_modules/logger");
const ansi_colors_1 = require("ansi-colors");
const option_1 = require("../../util_modules/option");
const urls_1 = __importDefault(require("../../util_modules/constants/lib/urls"));
const project_1 = require("../../util_modules/project");
exports.default = () => __awaiter(void 0, void 0, void 0, function* () {
    const dId = process.env.ZC_APP_DEPLOYMENT_BUILD_ID;
    const env = getEnvironmentType();
    if (!dId) {
        const targets = yield config_1.slateConfig.getAllTargetDetails(false);
        if (!targets || targets.length === 0) {
            throw new error_1.default('No targets found');
        }
        const filtered = slate_utils_1.slateUtils.filterTargets(targets);
        const validTargets = filtered.filter((targ) => {
            var _a, _b;
            if ((_a = targ.validity) === null || _a === void 0 ? void 0 : _a.valid) {
                return targ;
            }
            (0, logger_1.labeled)('Slate: ', 'Invalid Slate service ' + (0, ansi_colors_1.bold)(targ.name || 'Unknown')).ERROR();
            (0, logger_1.error)('Reason: ' + ((_b = targ.validity) === null || _b === void 0 ? void 0 : _b.reason));
            (0, logger_1.info)();
            return false;
        });
        if (validTargets.length === 0) {
            throw new error_1.default('No valid Slate services found to deploy', {
                skipHelp: true
            });
        }
        const slateAppConfigs = yield (yield (0, endpoints_1.slateAPI)({ env })).getAllApps();
        const throbber = throbber_1.default.getInstance();
        const deployRes = yield validTargets.reduce((result, _targ) => __awaiter(void 0, void 0, void 0, function* () {
            var _a;
            const targ = _targ;
            const prevRes = yield result;
            try {
                const throbberName = `prepare_slate_${targ.name}`;
                throbber.add(throbberName, {
                    text: `Preparing Slate[${targ.name}]`
                });
                const isAppExists = slateAppConfigs.find((app) => app.name === targ.name && app.app_type === 'cli');
                const configDetails = !isAppExists
                    ? (_a = (yield config_1.slateConfig.getTargetDetails(targ))) === null || _a === void 0 ? void 0 : _a.config
                    : undefined;
                const deploymentName = configDetails === null || configDetails === void 0 ? void 0 : configDetails.deployment_name;
                deploymentName ? configDetails === null || configDetails === void 0 ? true : delete configDetails.deployment_name : null;
                const readStream = yield slate_utils_1.slateUtils.pack(targ.source);
                throbber.remove(throbberName);
                const response = yield (yield (0, endpoints_1.slateAPI)({ env })).deploy(readStream.stream, readStream.length, targ.name, '', deploymentName ? deploymentName : '', isAppExists === null || isAppExists === void 0 ? void 0 : isAppExists.id, configDetails ? JSON.stringify(configDetails) : '', (0, option_1.getOptionValue)('m') || '');
                targ.details = response;
            }
            catch (err) {
                (0, logger_1.debug)(err);
                _targ.validity = {
                    valid: false,
                    reason: error_1.default.getErrorInstance(err).message
                };
            }
            prevRes.push(_targ);
            return Promise.resolve(prevRes);
        }), Promise.resolve([]));
        const deployedValidTargets = deployRes.filter((targ) => {
            var _a, _b, _c;
            if (!((_a = targ.validity) === null || _a === void 0 ? void 0 : _a.valid)) {
                (0, logger_1.warning)('Deploy of Slate [' +
                    targ.name +
                    '] was unsuccessful since ' +
                    ((_b = targ.validity) === null || _b === void 0 ? void 0 : _b.reason));
            }
            return (_c = targ.validity) === null || _c === void 0 ? void 0 : _c.valid;
        });
        runtime_store_1.default.set('context.payload.slate.targets', deployedValidTargets);
        if (deployedValidTargets.length > 0) {
            runtime_store_1.default.set('context.payload.slate.deploy', true);
        }
    }
    else {
        const source = runtime_store_1.default.get('cwd');
        yield slate_utils_1.slateUtils.validate(source);
        const readStream = yield slate_utils_1.slateUtils.pack();
        try {
            const deployRes = yield (yield (0, endpoints_1.slateAPI)({ env })).deploy(readStream.stream, readStream.length, process.env.ZC_APP_NAME, dId);
            deployRes.name = process.env.ZC_APP_NAME;
            runtime_store_1.default.set('context.payload.slate.targets', [deployRes]);
            runtime_store_1.default.set('context.payload.slate.deploy', true);
        }
        catch (err) {
            throw err;
        }
    }
});
function getEnvironmentType() {
    var _a;
    const isProduction = (0, option_1.getOptionValue)('production', false) ||
        ((_a = process.env.ZC_ENVIRONMENT) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'production';
    return isProduction ? 'Production' : 'Development';
}
exports.getEnvironmentType = getEnvironmentType;
function slateLogger() {
    const deployTargets = runtime_store_1.default.get('context.payload.slate.targets', []);
    deployTargets.forEach((slate) => {
        var _a, _b;
        (0, logger_1.labeled)(`Slate(${slate.name})`, 'Deploy is live!').SUCCESS();
        (0, logger_1.labeled)((0, ansi_colors_1.cyan)(`Build Url(${slate.name})`), `${urls_1.default.console}/baas/${(0, project_1.getEnvId)()}/project/${(0, project_1.getProjectId)()}/${getEnvironmentType()}#/slate/app/${(_a = slate.details) === null || _a === void 0 ? void 0 : _a.id}/deployment/${(_b = slate.details) === null || _b === void 0 ? void 0 : _b.deployment_type_config.upcoming_build.deployment_id}/overview`).MESSAGE();
        (0, logger_1.info)();
    });
    return deployTargets;
}
exports.slateLogger = slateLogger;
