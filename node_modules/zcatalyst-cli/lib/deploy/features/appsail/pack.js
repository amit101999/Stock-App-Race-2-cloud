"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.packAppSail = exports.packCustomAppSail = void 0;
const path_1 = require("path");
const error_1 = __importDefault(require("../../../error"));
const fs_1 = require("../../../util_modules/fs");
const constants_1 = require("../../../util_modules/constants");
const archiver_1 = __importDefault(require("../../../archiver"));
const minimatch_1 = __importDefault(require("minimatch"));
const container_plugin_1 = require("@zcatalyst/container-plugin");
const appsail_1 = require("../../../util_modules/config/lib/appsail");
function packCustomAppSail(_targ) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (true) {
            case _targ.source.startsWith(appsail_1.CONTAINER_IMAGE_PROTOCOLS.docker): {
                const img = _targ.source.replace(appsail_1.CONTAINER_IMAGE_PROTOCOLS.docker, '');
                const zipStream = yield (0, container_plugin_1.packImage)(img);
                const tmpFile = yield new Promise((resolve, reject) => {
                    try {
                        const tempFilePath = fs_1.SYNC.tempFile(_targ.name + '.tar');
                        const writeStream = fs_1.SYNC.getWriteStream(tempFilePath);
                        zipStream.pipe(writeStream);
                        zipStream
                            .on('end', () => {
                            resolve(tempFilePath);
                        })
                            .on('error', (err) => {
                            reject(error_1.default.getErrorInstance(err));
                        });
                    }
                    catch (er) {
                        reject(error_1.default.getErrorInstance(er));
                    }
                });
                const tmpFileDetails = yield fs_1.ASYNC.getFileDetails(tmpFile);
                return {
                    stream: fs_1.SYNC.getReadStream(tmpFile).pause(),
                    tmpFile: Object.assign({ path: tmpFile, cleanup: true }, tmpFileDetails)
                };
            }
            case _targ.source.startsWith(appsail_1.CONTAINER_IMAGE_PROTOCOLS.dockerArchive): {
                const tarFile = _targ.source.replace(appsail_1.CONTAINER_IMAGE_PROTOCOLS.dockerArchive, '');
                const isTarFile = yield fs_1.ASYNC.fileExists(tarFile);
                if (!isTarFile) {
                    throw new error_1.default('Invalid docker archive file: ' + tarFile, {
                        exit: 1
                    });
                }
                const tmpFileDetails = yield fs_1.ASYNC.getFileDetails(tarFile);
                return {
                    stream: fs_1.SYNC.getReadStream(tarFile).pause(),
                    tmpFile: Object.assign({ path: tarFile, cleanup: false }, tmpFileDetails)
                };
            }
            default: {
                throw new error_1.default('Invalid container image protocol: ' + _targ.source, {
                    exit: 1
                });
            }
        }
    });
}
exports.packCustomAppSail = packCustomAppSail;
function packAppSail(_targ) {
    return __awaiter(this, void 0, void 0, function* () {
        const targ = _targ.config;
        if (!targ) {
            throw new error_1.default('Invalid AppSail target to pack: ' + _targ.name, {
                context: targ,
                exit: 2
            });
        }
        const folderPath = targ.build_path;
        if (!folderPath) {
            throw new error_1.default('Invalid build path for AppSail target: ' + _targ.name, {
                context: _targ,
                exit: 2
            });
        }
        const isBuildPath = yield fs_1.ASYNC.isPathExists(folderPath);
        if (!isBuildPath) {
            throw new error_1.default(`the build path doesn't exists: ${folderPath}`, {
                exit: 1,
                skipHelp: true
            });
        }
        const ignoreFile = yield fs_1.ASYNC.readFile((0, path_1.join)(_targ.source, constants_1.FILENAME.catalyst_ignore));
        const excludePatterns = [
            '**/.DS_Store',
            '**/.vscode/**/*',
            `**/${constants_1.FILENAME.log}`,
            `**/${constants_1.FILENAME.config}`,
            `**/${constants_1.FILENAME.rc}`,
            `**/${constants_1.FILENAME.app_config}`,
            `**/${constants_1.FILENAME.catalyst_ignore}`,
            ...((ignoreFile === null || ignoreFile === void 0 ? void 0 : ignoreFile.split('\n')) || [])
        ];
        const folderContents = yield fs_1.ASYNC.walk(folderPath, {
            filter: {
                exclude: (path) => __awaiter(this, void 0, void 0, function* () {
                    return !!excludePatterns.find((glob) => (0, minimatch_1.default)(path.replace(folderPath + path_1.sep, ''), glob, { dot: true }));
                }),
                excludeDir: true
            }
        });
        const zip = new archiver_1.default();
        folderContents.forEach((content) => {
            zip.add(content.path === folderPath
                ? (0, path_1.basename)(content.path)
                : content.path.replace(folderPath + path_1.sep, ''), content.stats.isSymbolicLink()
                ? fs_1.SYNC.readSymLink(content.path)
                : fs_1.SYNC.getReadStream(content.path), { mode: content.stats.mode });
        });
        const finalized = yield zip.finalize();
        return finalized.fsStream();
    });
}
exports.packAppSail = packAppSail;
