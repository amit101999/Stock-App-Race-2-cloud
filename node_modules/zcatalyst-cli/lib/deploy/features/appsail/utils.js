"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStandAloneTarget = exports.getConfigJsonInputs = exports.urlLogger = exports.validatePlatform = exports.validateStack = exports.validateBuildPath = exports.validateOptions = void 0;
const path_1 = require("path");
const runtime_store_1 = __importDefault(require("../../../runtime-store"));
const appsail_1 = require("../../../util_modules/config/lib/appsail");
const constants_1 = require("../../../util_modules/constants");
const fs_1 = require("../../../util_modules/fs");
const common_1 = require("../../../init/util/common");
const prompt_1 = __importDefault(require("../../../prompt"));
const project_1 = require("../../../util_modules/project");
const error_1 = __importDefault(require("../../../error"));
const index_1 = require("../../../util_modules/logger/index");
const option_1 = require("../../../util_modules/option");
const util_1 = require("../../util");
const ansi_colors_1 = require("ansi-colors");
const utils_1 = require("../../../init/features/appsail/utils");
function validateOptions(validationFn, option, ...args) {
    return __awaiter(this, void 0, void 0, function* () {
        const value = (0, option_1.getOptionValue)(option, false);
        if (value === false) {
            return false;
        }
        const validationRes = yield validationFn(value, ...args);
        if (validationRes === false) {
            (0, index_1.debug)(`Invalid value for option: ${option}`);
            return false;
        }
        return validationRes;
    });
}
exports.validateOptions = validateOptions;
function validateBuildPath(path) {
    return __awaiter(this, void 0, void 0, function* () {
        const cwd = runtime_store_1.default.get('cwd');
        if (path) {
            const buildPath = (0, path_1.isAbsolute)(path) ? path : (0, path_1.resolve)(cwd, path);
            return (yield fs_1.ASYNC.isPathExists(buildPath)) ? path : false;
        }
        return false;
    });
}
exports.validateBuildPath = validateBuildPath;
function validateStack(stack, stackPromise) {
    return __awaiter(this, void 0, void 0, function* () {
        const runtimeStacks = yield stackPromise;
        if (runtimeStacks.runtimes.includes(stack)) {
            return {
                runtime: stack,
                lang: Object.keys(constants_1.RUNTIME.language).find((lang) => stack.startsWith(lang))
            };
        }
        return false;
    });
}
exports.validateStack = validateStack;
function validatePlatform(platform, stack) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!stack || stack.lang === constants_1.RUNTIME.language.java.value) {
            return ['javase', 'war'].includes(platform) ? platform : false;
        }
        return false;
    });
}
exports.validatePlatform = validatePlatform;
function urlLogger() {
    const deployTargets = runtime_store_1.default.get('context.payload.appsail.targets', []);
    (0, util_1.logPaddedLabels)(deployTargets.reduce((logTargs, sail) => {
        logTargs.push({
            label: 'DEPLOYMENT SUCCESSFUL',
            message: sail.name,
            logType: 'SUCCESS'
        });
        logTargs.push({
            label: 'APPSAIL URL',
            message: (0, ansi_colors_1.underline)(sail.url || 'Unknown'),
            logType: 'MESSAGE'
        });
        logTargs.push('');
        return logTargs;
    }, []));
    return deployTargets;
}
exports.urlLogger = urlLogger;
function getConfigJsonInputs() {
    return __awaiter(this, void 0, void 0, function* () {
        const runtimeDetailsPromise = (0, common_1.getRuntimeDetails)();
        const stack = yield validateOptions(validateStack, 'stack', runtimeDetailsPromise);
        const platform = yield validateOptions(validatePlatform, 'platform', stack);
        const optValues = {
            build_path: yield validateOptions(validateBuildPath, 'buildPath'),
            stack,
            platform,
            command: (0, option_1.getOptionValue)('command', false)
        };
        yield prompt_1.default.register('file-path');
        const appConfigAns = yield prompt_1.default.ask(prompt_1.default.question('build_path', 'Please provide the build directory of your AppSail:', {
            type: 'input',
            when: () => optValues.build_path === false,
            validate: (value) => __awaiter(this, void 0, void 0, function* () {
                const pathRes = yield validateBuildPath(value);
                if (!pathRes) {
                    return `Invalid path: ${value}`;
                }
                return true;
            })
        }), prompt_1.default.question('stack', 'Please select the stack for your AppSail:', {
            type: 'list',
            choices: yield (0, common_1.getRuntimeChoices)({ runtimeDetails: yield runtimeDetailsPromise }),
            when: () => optValues.stack === false
        }), prompt_1.default.question('platform', 'Please choose a platform for your AppSail: ', {
            type: 'list',
            choices: [
                prompt_1.default.choice('JavaSE', {
                    value: 'javase',
                    short: 'JavaSE'
                }),
                prompt_1.default.choice('JavaWAR', {
                    value: 'war',
                    short: 'JavaWAR'
                })
            ],
            when: (answers) => {
                var _a;
                const _stack = ((_a = answers.stack) === null || _a === void 0 ? void 0 : _a.lang) ||
                    (typeof optValues.stack === 'boolean' ? '' : optValues.stack.lang) ||
                    '';
                return (optValues.platform === false &&
                    _stack.startsWith(constants_1.RUNTIME.language.java.value));
            }
        }), prompt_1.default.question('command', 'Please specify the command to start the AppSail:', {
            type: 'input',
            when: (answers) => {
                var _a;
                const stack = ((_a = answers.stack) === null || _a === void 0 ? void 0 : _a.lang) ||
                    (typeof optValues.stack === 'boolean' ? '' : optValues.stack.lang) ||
                    '';
                const _platform = answers.platform || optValues.platform || '';
                return (optValues.command === false &&
                    !(stack.startsWith(constants_1.RUNTIME.language.java.value) &&
                        _platform === 'war'));
            }
        }));
        const finalConfig = Object.entries(optValues).reduce((config, [key, val]) => {
            config[key] = val === false ? appConfigAns[key] : val;
            return config;
        }, {});
        if (typeof finalConfig.stack !== 'string') {
            finalConfig.stack = finalConfig.stack.runtime;
        }
        if (!finalConfig.stack.startsWith(constants_1.RUNTIME.language.java.value) &&
            finalConfig.platform) {
            (0, index_1.message)('Platform argument is not supported for stack: ' + finalConfig.stack);
            delete finalConfig.platform;
        }
        if (finalConfig.platform === 'war' && finalConfig.command) {
            (0, index_1.message)('Command argument not need for platform type war');
            delete finalConfig.command;
        }
        return finalConfig;
    });
}
exports.getConfigJsonInputs = getConfigJsonInputs;
function getStandAloneTarget() {
    return __awaiter(this, void 0, void 0, function* () {
        const isProjectInfo = (0, project_1.getProjectId)(false) || (0, project_1.getProjectName)(false);
        if (!isProjectInfo) {
            throw new error_1.default('Project info is not present');
        }
        const cwd = runtime_store_1.default.get('cwd');
        const catalystConfigPath = (0, path_1.join)(cwd, constants_1.FILENAME.app_config);
        const imgSourceOpt = (0, option_1.getOptionValue)('source');
        const imgSource = yield (() => __awaiter(this, void 0, void 0, function* () {
            const tag = imgSourceOpt;
            if (tag === undefined) {
                (0, index_1.debug)('--source option not specified. Hence, using Catalyst runtime');
                return false;
            }
            if (tag.startsWith(appsail_1.CONTAINER_IMAGE_PROTOCOLS.dockerArchive)) {
                const tarPath = tag.replace(appsail_1.CONTAINER_IMAGE_PROTOCOLS.dockerArchive, '');
                const normalizedTarPath = (0, path_1.isAbsolute)(tarPath) ? tarPath : (0, path_1.resolve)(cwd, tarPath);
                return `docker-archive://${normalizedTarPath}`;
            }
            return tag;
        }))();
        const nameOpt = yield validateOptions(((name) => __awaiter(this, void 0, void 0, function* () {
            if (!name.match(constants_1.REGEX.appsail.name)) {
                (0, index_1.info)();
                (0, index_1.warning)(`Skipping ${(0, ansi_colors_1.yellow)('--name')} option. Since AppSail name value supplied with the option is invalid`);
                (0, index_1.warning)('Name must contain only alphanumeric and hyphen');
                (0, index_1.info)();
                return false;
            }
            return name;
        })), 'name');
        const appSailName = nameOpt ? nameOpt : yield (0, utils_1.getAppSailName)();
        if (typeof imgSource === 'string') {
            return {
                source: imgSource,
                runtime: 'custom',
                name: appSailName,
                validity: {
                    valid: true
                },
                config: {
                    command: (0, option_1.getOptionValue)('command', undefined),
                    port: {
                        http: Number((0, option_1.getOptionValue)('port', undefined)) || undefined
                    },
                    raw: {}
                }
            };
        }
        const configJson = (yield fs_1.ASYNC.readJSONFile(catalystConfigPath).catch((err) => (0, index_1.debug)(err))) || (yield getConfigJsonInputs());
        if (typeof configJson.stack === 'object') {
            configJson.stack = configJson.stack.runtime;
        }
        return {
            name: appSailName,
            runtime: 'catalyst',
            source: cwd,
            config: configJson,
            validity: { valid: true }
        };
    });
}
exports.getStandAloneTarget = getStandAloneTarget;
