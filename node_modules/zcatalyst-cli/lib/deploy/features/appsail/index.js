"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeHook = void 0;
const ansi_colors_1 = require("ansi-colors");
const appsail_utils_1 = require("../../../appsail-utils");
const endpoints_1 = require("../../../endpoints");
const error_1 = __importDefault(require("../../../error"));
const execute_script_1 = require("../../../execute-script");
const runtime_store_1 = __importDefault(require("../../../runtime-store"));
const config_1 = require("../../../util_modules/config");
const index_1 = require("../../../util_modules/logger/index");
const option_1 = require("../../../util_modules/option");
const throbber_1 = __importDefault(require("../../../throbber"));
const utils_1 = require("./utils");
const pack_1 = require("./pack");
const fs_1 = require("../../../util_modules/fs");
function executeHook(script, name, moduleSource) {
    return __awaiter(this, void 0, void 0, function* () {
        if ((0, option_1.getOptionValue)('ignoreScripts', false)) {
            (0, index_1.debug)(`skipping ${name} hook`);
            return;
        }
        return (0, execute_script_1.executeCommand)(script, { moduleSource, feature: name });
    });
}
exports.executeHook = executeHook;
exports.default = (standAlone = false) => __awaiter(void 0, void 0, void 0, function* () {
    const targets = standAlone
        ? [yield (0, utils_1.getStandAloneTarget)()]
        : yield config_1.appSailConfig.getAllTargetDetails();
    if (!targets || targets.length === 0) {
        throw new error_1.default('No targets found');
    }
    const filtered = (0, appsail_utils_1.filterTargets)(targets);
    const validTargets = (yield (0, appsail_utils_1.validateAppSail)(filtered)).filter((targ) => {
        if (targ.validity.valid) {
            return targ;
        }
        (0, index_1.labeled)('AppSail: ', 'Invalid AppSail ' + (0, ansi_colors_1.bold)(targ.name || 'Unknown')).ERROR();
        (0, index_1.error)('Reason: ' + targ.validity.reason);
        (0, index_1.info)();
        return false;
    });
    if (validTargets.length === 0) {
        throw new error_1.default('No valid AppSails found to deploy', {
            skipHelp: true
        });
    }
    const sailAPI = yield (0, endpoints_1.appSailAPI)();
    const throbber = throbber_1.default.getInstance();
    const deployRes = yield validTargets.reduce((result, _targ) => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b;
        const targ = _targ.config;
        const prevRes = yield result;
        const throbberName = `prepare_appsail_${_targ.name}`;
        try {
            if ((_a = targ.scripts) === null || _a === void 0 ? void 0 : _a.predeploy) {
                yield executeHook(targ.scripts.predeploy, 'predeploy', _targ.source);
            }
            switch (_targ.runtime) {
                case 'custom': {
                    throbber.add(throbberName, {
                        text: `Preparing AppSail[${_targ.name}]`
                    });
                    const zipStream = yield (0, pack_1.packCustomAppSail)(_targ);
                    const uploadDetails = yield sailAPI.getSignedUrl(_targ.name);
                    throbber.remove(throbberName);
                    yield sailAPI.uploadToBucket({
                        signedUrl: uploadDetails.signed_url,
                        length: zipStream.tmpFile.size,
                        stream: zipStream.stream,
                        name: _targ.name
                    });
                    const fileCleanupPromise = zipStream.tmpFile.cleanup
                        ? fs_1.ASYNC.deleteFile(zipStream.tmpFile.path)
                        : Promise.resolve();
                    throbber.add(throbberName, {
                        text: `Deploying AppSail[${_targ.name}]`
                    });
                    const callBackRes = yield sailAPI.customAppSailCallback(_targ, uploadDetails.object_key);
                    yield fileCleanupPromise;
                    throbber.remove(throbberName);
                    _targ.url = callBackRes.url;
                    break;
                }
                case 'catalyst': {
                    throbber.add(throbberName, {
                        text: `Preparing AppSail[${_targ.name}]`
                    });
                    const zipStream = yield (0, pack_1.packAppSail)(_targ);
                    throbber.remove(throbberName);
                    const { stack, command, platform, env_variables, catalyst_auth, login_redirect, port } = targ;
                    let { memory } = targ;
                    if (!memory && _targ.name) {
                        const existingAppSail = (yield sailAPI.getAllAppsails()).find((sail) => sail.name === _targ.name);
                        if (existingAppSail && existingAppSail.configuration.memory) {
                            memory = existingAppSail.configuration.memory;
                        }
                        else {
                            memory = 256;
                        }
                    }
                    const apiRes = yield sailAPI.deploy(zipStream.stream, {
                        stack: stack,
                        name: _targ.name,
                        memory,
                        platform,
                        command,
                        catalystAuth: catalyst_auth,
                        loginRedirect: login_redirect,
                        envVariables: env_variables,
                        contentLength: zipStream.length,
                        port: port === null || port === void 0 ? void 0 : port.http
                    });
                    _targ.url = apiRes.url;
                    break;
                }
                default: {
                    throw new error_1.default(`Invalid AppSail runtime type "${_targ.runtime}" for AppSail ${_targ.name}`, { exit: 1 });
                }
            }
            if ((_b = targ.scripts) === null || _b === void 0 ? void 0 : _b.postdeploy) {
                yield executeHook(targ.scripts.postdeploy, 'postdeploy', _targ.source);
            }
        }
        catch (err) {
            throbber.remove(throbberName);
            (0, index_1.debug)(err);
            _targ.validity = {
                valid: false,
                reason: error_1.default.getErrorInstance(err).message
            };
        }
        prevRes.push(_targ);
        return Promise.resolve(prevRes);
    }), Promise.resolve([]));
    const deployedValidTargets = deployRes.filter((targ) => {
        if (!targ.validity.valid) {
            (0, index_1.warning)('Deploy of AppSail [' +
                targ.name +
                '] was unsuccessful since ' +
                targ.validity.reason);
        }
        return targ.validity.valid;
    });
    runtime_store_1.default.set('context.payload.appsail.targets', deployedValidTargets);
    if (deployedValidTargets.length > 0) {
        runtime_store_1.default.set('context.payload.appsail.deploy', true);
    }
});
