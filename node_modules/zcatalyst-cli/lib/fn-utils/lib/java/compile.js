"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.printCompilationLog = exports.compileTarget = exports.warningMessages = void 0;
const path_1 = require("path");
const constants_1 = require("../../../util_modules/constants");
const ensure_java_userconfig_1 = require("./ensure-java-userconfig");
const fs_1 = require("../../../util_modules/fs");
const config_1 = require("../../../util_modules/config");
const option_1 = require("../../../util_modules/option");
const index_1 = require("../../../util_modules/logger/index");
const shell_1 = require("../../../util_modules/shell");
const ansi_colors_1 = require("ansi-colors");
const logger_1 = require("../../../util_modules/logger");
const _1 = require(".");
const userConfig_1 = __importDefault(require("../../../userConfig"));
exports.warningMessages = [
    'warning: [options] bootstrap class path not set in conjunction with -source 8',
    'warning: [options] system modules path not set in conjunction with -source 11'
];
function compileTarget(target) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const targetSource = target.source;
        const outputFolder = (0, path_1.join)(targetSource, constants_1.FOLDERNAME.output);
        const integ = target.integ_config;
        const entries = [(0, path_1.join)(targetSource, ((_a = target.index) === null || _a === void 0 ? void 0 : _a.replace(/\./g, path_1.sep)) + '.java')];
        if (integ && integ.length > 0) {
            integ.forEach((integConf) => {
                const handlers = integConf.handlers;
                handlers &&
                    Object.keys(handlers).forEach((handler) => {
                        entries.push((0, path_1.join)(targetSource, handlers[handler].replace(/\./g, path_1.sep) + '.java'));
                    });
            });
        }
        yield fs_1.ASYNC.ensureDir(outputFolder);
        yield fs_1.ASYNC.emptyDir(outputFolder);
        const ignore = config_1.functionsConfig.ignore(targetSource);
        const allFiles = yield fs_1.ASYNC.walk(targetSource, {
            filter: { exclude: ['**/.output', ...ignore], excludeDir: true }
        });
        const cleanUpFiles = allFiles.map((file) => file.path);
        while (allFiles.length > 0) {
            const limit = allFiles.length < 20 ? allFiles.length : 20;
            yield Promise.all(allFiles.splice(0, limit).map((file) => {
                const targetPth = file.path.includes(path_1.sep + 'lib' + path_1.sep)
                    ? file.path.replace(targetSource + path_1.sep + 'lib', '')
                    : file.path.replace(targetSource, '');
                return fs_1.ASYNC.copyFile(file.path, (0, path_1.join)(outputFolder, targetPth));
            }));
        }
        const targetVersion = (0, ensure_java_userconfig_1.getTargetVersion)(target.stack);
        const spawnCommand = (0, ensure_java_userconfig_1.getJavaSpawnCommand)('javac', (_b = target.additionalInfo) === null || _b === void 0 ? void 0 : _b.binPath);
        yield Promise.all(entries.map((file) => compileJavaFiles(file, spawnCommand, targetVersion, targetSource, outputFolder)
            .then((result) => {
            const [_stdout, stderr, code] = result;
            if (code === null || code >= 1) {
                const error = [];
                error === null || error === void 0 ? void 0 : error.push(stderr);
                target.valid = false;
                target.failure_reason = 'there was a Java compilation error';
                if (!target.additionalInfo) {
                    return;
                }
                target.additionalInfo.compilerOut.error = error;
            }
            else if (stderr) {
                if (!target.additionalInfo) {
                    return;
                }
                target.additionalInfo.compilerOut.warning = [stderr];
            }
        })
            .catch((error) => {
            target.valid = false;
            target.failure_reason = error.message;
        })));
        const currentCommand = (0, option_1.getCurrentCommand)();
        switch (currentCommand) {
            case 'pull':
            case 'init':
                yield cleanUp(cleanUpFiles);
                break;
            case 'deploy':
                const classPath = (0, path_1.join)(outputFolder, constants_1.FILENAME.functions.java_classpath);
                if (yield fs_1.ASYNC.fileExists(classPath)) {
                    const classPathFile = yield fs_1.ASYNC.readFile(classPath);
                    if (classPathFile) {
                        yield fs_1.ASYNC.writeFile(classPath, classPathFile.replace(/lib[\\|\/]/g, ''));
                    }
                }
                break;
        }
    });
}
exports.compileTarget = compileTarget;
function compileJavaFiles(file, spawnCommand, targetVersion, targetSource, outputFolder) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, index_1.message)('Compiling ' + file);
        return new Promise((resolve, reject) => {
            var _a, _b;
            const child = (0, shell_1.spawn)(spawnCommand, [
                '-target',
                targetVersion,
                '-source',
                targetVersion,
                '-cp',
                '*' + _1.classPathSep + '.',
                '-g',
                '-Xprefer:source',
                userConfig_1.default.get('javac.disable_warnings') === 'true' ? '-Xlint:none' : '-Xlint',
                file.replace(targetSource, outputFolder)
            ], {
                cwd: outputFolder,
                stdio: 'pipe'
            }).RAW();
            let stdout = '';
            let stderr = '';
            (_a = child.stdout) === null || _a === void 0 ? void 0 : _a.on('data', (data) => {
                stdout += data.toString();
            });
            (_b = child.stderr) === null || _b === void 0 ? void 0 : _b.on('data', (data) => {
                const err = data.toString();
                let newErr = '';
                exports.warningMessages.forEach((element) => {
                    if (err.includes(element)) {
                        newErr += err.replace(element, '');
                    }
                });
                if (!newErr) {
                    newErr += err;
                }
                stderr += newErr;
            });
            child.on('error', (error) => {
                reject(error);
            });
            child.on('close', (code) => {
                resolve([stdout, stderr, code]);
            });
        });
    });
}
function cleanUp(files) {
    return __awaiter(this, void 0, void 0, function* () {
        const promiseArr = [];
        const deleteArr = [];
        const hashes = {};
        files.forEach((file, idx) => {
            if (file.endsWith('.java')) {
                const hash = hashes[file];
                if (hash === undefined) {
                    hashes[file] = { found: true, acc: [] };
                }
                else {
                    hash.found = true;
                    deleteArr.push(...hash.acc);
                }
            }
            else if (file.endsWith('.class')) {
                const javaFile = file.replace(new RegExp('(\\$+[0-9]+)?\\.class$', 'g'), '.java');
                const hashValue = hashes[javaFile];
                if (hashValue === undefined) {
                    hashes[javaFile] = { found: false, acc: [file] };
                }
                else if (hashValue.found === true) {
                    files.splice(idx, 1);
                    promiseArr.push(fs_1.ASYNC.deleteFile(file));
                }
                else if (hashValue.found === false) {
                    hashValue.acc.push(file);
                }
            }
        });
        return Promise.all([...deleteArr.map((file) => fs_1.ASYNC.deleteFile(file)), ...promiseArr]);
    });
}
function printCompilationLog(javaFns) {
    const isJavaFnLog = javaFns === null || javaFns === void 0 ? void 0 : javaFns.some((target) => {
        var _a, _b, _c, _d, _e, _f;
        return ((_c = (_b = (_a = target.additionalInfo) === null || _a === void 0 ? void 0 : _a.compilerOut) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.length) ||
            ((_f = (_e = (_d = target.additionalInfo) === null || _d === void 0 ? void 0 : _d.compilerOut) === null || _e === void 0 ? void 0 : _e.warning) === null || _f === void 0 ? void 0 : _f.length);
    });
    if (isJavaFnLog) {
        index_1.local.info();
        index_1.local.info((0, ansi_colors_1.italic)('Java Compilation logs: '));
        javaFns === null || javaFns === void 0 ? void 0 : javaFns.forEach((target) => {
            var _a, _b, _c, _d;
            const error = (_b = (_a = target.additionalInfo) === null || _a === void 0 ? void 0 : _a.compilerOut) === null || _b === void 0 ? void 0 : _b.error;
            if (error && error.length > 0) {
                index_1.local.info();
                index_1.local.info(`${(0, ansi_colors_1.red)(logger_1.CHAR.error)} Error while compiling the function[${target.name}]`);
                index_1.local.info();
            }
            error === null || error === void 0 ? void 0 : error.forEach((error) => {
                index_1.local.info(error);
            });
            const warning = (_d = (_c = target.additionalInfo) === null || _c === void 0 ? void 0 : _c.compilerOut) === null || _d === void 0 ? void 0 : _d.warning;
            if (warning && warning.length > 0) {
                index_1.local.info();
                index_1.local.warn(`${(0, ansi_colors_1.yellow)(logger_1.CHAR.warning)} Warning while compiling the function[${target.name}]`);
                index_1.local.info();
            }
            warning === null || warning === void 0 ? void 0 : warning.forEach((warn) => {
                index_1.local.warn(warn);
            });
        });
    }
}
exports.printCompilationLog = printCompilationLog;
