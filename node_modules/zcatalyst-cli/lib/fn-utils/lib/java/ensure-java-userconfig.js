'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTargetVersion = exports.getJavaSpawnCommand = exports.ensureJava = exports.stackVsVersions = void 0;
const semver_1 = require("semver");
const error_1 = __importDefault(require("../../../error"));
const runtime_store_1 = __importDefault(require("../../../runtime-store"));
const userConfig_1 = __importDefault(require("../../../userConfig"));
const shell_1 = require("../../../util_modules/shell");
const path_1 = require("path");
const ansi_colors_1 = require("ansi-colors");
const index_1 = require("../../../util_modules/logger/index");
const env_1 = require("../../../util_modules/env");
const jdk_utils_1 = require("jdk-utils");
exports.stackVsVersions = {
    java8: {
        version: '1.8.x',
        target: '1.8',
        label: 'Java 8'
    },
    java11: {
        version: '11.x',
        target: '11',
        label: 'Java 11'
    },
    java17: {
        version: '17.x',
        target: '17',
        label: 'Java 17'
    }
};
class JavaRuntimes {
    constructor(runtimes) {
        this.runtimes = {};
        runtimes.forEach((runT) => {
            var _a;
            const major = (_a = runT.version) === null || _a === void 0 ? void 0 : _a.major;
            if (!major) {
                return;
            }
            if (!this.runtimes[major]) {
                this.runtimes[major] = [];
            }
            this.runtimes[major].push(runT);
        });
    }
    static init() {
        return __awaiter(this, void 0, void 0, function* () {
            return new JavaRuntimes(yield (0, jdk_utils_1.findRuntimes)({ checkJavac: true, withVersion: true, withTags: true }));
        });
    }
    get(version) {
        version = version.replace('java', '');
        return this.runtimes[version];
    }
    getBinPath(version) {
        var _a, _b;
        version = version.replace('java', '');
        const home = (_b = (_a = this.runtimes[version]) === null || _a === void 0 ? void 0 : _a.at(0)) === null || _b === void 0 ? void 0 : _b.homedir;
        if (!home) {
            return;
        }
        return (0, path_1.join)(home, 'bin');
    }
}
function ensureJava(stack) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const configKey = `${stack}.bin`;
        const binPath = env_1.isVsCode
            ? runtime_store_1.default.get(`executables.${configKey}`)
            : userConfig_1.default.get(configKey);
        if (!binPath) {
            const javaRuntimes = yield JavaRuntimes.init();
            const runtimeArr = javaRuntimes.get(stack);
            if (runtimeArr && runtimeArr.length > 1) {
                if (env_1.isVsCode) {
                    (0, index_1.info)();
                    (0, index_1.labeled)(stack, `Found more than one java runtime for java major version ${stack.replace('java', '')} in the below paths`).WARN();
                    runtimeArr === null || runtimeArr === void 0 ? void 0 : runtimeArr.forEach((rn) => {
                        (0, index_1.labeled)(stack, '  * ' + rn.homedir).WARN();
                    });
                    (0, index_1.info)();
                    (0, index_1.labeled)(stack, `Please specify the required java runtime for stack ${stack} using the "zcatalyst.${configKey}" config`).WARN();
                    (0, index_1.info)();
                    return;
                }
                const rnWithJavac = runtimeArr.find((rn) => rn.hasJavac);
                throw new error_1.default('Found more than one java version for stack : ' + stack, {
                    exit: 1,
                    errorId: 'JAVA_CONFIG_MORE_RN',
                    arg: [
                        stack.replace('java', ''),
                        runtimeArr.map((rn) => '* ' + rn.homedir).join('\n'),
                        (0, ansi_colors_1.bold)('catalyst config:set'),
                        (0, ansi_colors_1.bold)(`catalyst config:set ${configKey}=${(rnWithJavac && (0, ansi_colors_1.underline)((0, path_1.join)(rnWithJavac.homedir, 'bin'))) ||
                            '<java_bin_folder_path>'}`)
                    ]
                });
            }
            const runtime = runtimeArr === null || runtimeArr === void 0 ? void 0 : runtimeArr.at(0);
            if (!runtime) {
                if (env_1.isVsCode) {
                    (0, index_1.labeled)(stack, 'Unable to detect the java version for stack: ' + stack).ERROR();
                    (0, index_1.labeled)(stack, `Please install the required JDK version and configure it using the "zcatalyst.${configKey}" settings`).ERROR();
                    (0, index_1.info)();
                }
                throw new error_1.default('Unable to detect the java version for stack: ' + stack, {
                    errorId: 'JAVA_CONFIG-1',
                    exit: 1,
                    arg: [stack]
                });
            }
            if (!runtime.hasJavac) {
                if (env_1.isVsCode) {
                    (0, index_1.labeled)(stack, 'Unable to detect the javac executable for stack: ' + stack).ERROR();
                    (0, index_1.labeled)(stack, 'Please install the required JDK version and configure it using the ' + env_1.isVsCode
                        ? ` "catalyst config:set ${configKey}=<java_bin_dir_path>" command`
                        : `zcatalyst.${configKey} settings`).ERROR();
                    (0, index_1.info)();
                }
                throw new error_1.default('Unable to detect javac executable for stack: ' + stack, {
                    errorId: 'JAVA_CONFIG_JAVAC',
                    exit: 1,
                    arg: [stack]
                });
            }
            return (0, path_1.join)(runtime.homedir, 'bin');
        }
        if (binPath === 'java') {
            const runtime = (yield JavaRuntimes.init()).get(stack);
            const wJavac = runtime === null || runtime === void 0 ? void 0 : runtime.find((rn) => rn.hasJavac);
            throw new error_1.default('Cannot specify the java command in config', {
                exit: 1,
                errorId: 'JAVA_CONFIG_2',
                arg: [
                    (0, ansi_colors_1.bold)(configKey),
                    ansi_colors_1.bold.red(binPath),
                    (0, ansi_colors_1.bold)('catalyst config:set'),
                    (0, ansi_colors_1.bold)('catalyst config:set ' +
                        configKey +
                        '=' +
                        (wJavac ? (0, ansi_colors_1.underline)((0, path_1.join)(wJavac.homedir, 'bin')) : '<java_bin_dir_path>'))
                ]
            });
        }
        try {
            const foundStack = yield findJavaVersion(binPath);
            if (!foundStack || !(foundStack in exports.stackVsVersions)) {
                if (env_1.isVsCode) {
                    (0, index_1.labeled)(stack, `The required Java runtime version for ${stack} was not found in the supplied setting zcatalyst.${configKey}=${(0, ansi_colors_1.underline)(binPath)}`).ERROR();
                    (0, index_1.labeled)(stack, `Please install the required java version and configure it using the zcatalyst.${configKey} settings`).ERROR();
                    (0, index_1.info)();
                    return;
                }
                throw new error_1.default('Unable to find the required java version from bin path: ' + binPath, {
                    exit: 1,
                    errorId: 'JAVA_CONFIG-1A',
                    arg: [(0, ansi_colors_1.bold)(configKey), (0, ansi_colors_1.underline)((0, path_1.join)(binPath, (0, ansi_colors_1.red)('java'))), stack, 'java']
                });
            }
            if (foundStack !== stack) {
                if (env_1.isVsCode) {
                    (0, index_1.labeled)(stack, `The version of java executable found in the bin path from the config ${stack}.bin does not match with the required stack`).ERROR();
                    (0, index_1.labeled)(stack, `Please specify a valid bin path for the stack ${stack} in the settings "zcatalyst.${configKey}"`).ERROR();
                    (0, index_1.info)();
                    return;
                }
                throw new error_1.default('Bin path version mismatch', {
                    exit: 1,
                    errorId: 'JAVA_CONFIG_V_MISS',
                    arg: [(0, ansi_colors_1.bold)(configKey), (0, ansi_colors_1.bold)(stack)]
                });
            }
        }
        catch (er) {
            const error = error_1.default.getErrorInstance(er, { skipHelp: true });
            if (error.original instanceof Error &&
                'code' in error.original &&
                ((_a = error.original) === null || _a === void 0 ? void 0 : _a.code) === 'ENOENT') {
                throw new error_1.default('Unable to find the java executable in your machine', {
                    exit: 1,
                    errorId: 'JAVA_CONFIG-1A',
                    original: error,
                    arg: [(0, ansi_colors_1.bold)(`${stack}.bin`), (0, ansi_colors_1.underline)((0, path_1.join)(binPath, (0, ansi_colors_1.red)('java'))), stack, 'java']
                });
            }
            throw error;
        }
        try {
            yield findJavaCVersion(binPath);
        }
        catch (er) {
            const error = error_1.default.getErrorInstance(er, { skipHelp: true });
            if (error.original instanceof Error &&
                'code' in error.original &&
                error.original.code === 'ENOENT') {
                throw new error_1.default(`Unable to check the javac version using the given binary path: ${binPath}`, {
                    exit: 1,
                    errorId: 'JAVA_CONFIG-1A',
                    arg: [
                        (0, ansi_colors_1.bold)(`${stack}.bin`),
                        (0, ansi_colors_1.underline)((0, path_1.join)(binPath, (0, ansi_colors_1.red)('javac'))),
                        stack,
                        'javac'
                    ]
                });
            }
            throw error;
        }
        return binPath ? binPath : '';
    });
}
exports.ensureJava = ensureJava;
function findJavaVersion(bin) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const javaVersionOut = yield (0, shell_1.spawn)(getJavaSpawnCommand('java', bin), ['-version'], {
            stdio: 'pipe'
        }).ASYNC();
        const version = (_a = (javaVersionOut.stdout || javaVersionOut.stderr).match(/"([0-9._]+)"/)) === null || _a === void 0 ? void 0 : _a.at(1);
        if (!version) {
            throw new error_1.default('Unable to detect the version for the java executable from path: ' + bin, {
                exit: 2
            });
        }
        const coercedVersion = (0, semver_1.coerce)(version);
        if (!coercedVersion) {
            return;
        }
        return Object.keys(exports.stackVsVersions).find((stack) => (0, semver_1.satisfies)(coercedVersion, exports.stackVsVersions[stack].version));
    });
}
function findJavaCVersion(bin) {
    return __awaiter(this, void 0, void 0, function* () {
        const javaCVersionOut = yield (0, shell_1.spawn)(getJavaSpawnCommand('javac', bin), ['-version'], {
            stdio: 'pipe'
        }).ASYNC();
        const javaCVersion = (0, semver_1.valid)((0, semver_1.coerce)((javaCVersionOut.stdout || javaCVersionOut.stderr).split(' ')[1]));
        if (!javaCVersion) {
            throw new error_1.default('Unable to detect the version for the javac executable from path: ' + bin, { exit: 2 });
        }
        return javaCVersion;
    });
}
function getJavaSpawnCommand(process, binPath) {
    return binPath ? (0, path_1.join)(binPath, process) : process;
}
exports.getJavaSpawnCommand = getJavaSpawnCommand;
function getTargetVersion(stack) {
    return exports.stackVsVersions[stack].target;
}
exports.getTargetVersion = getTargetVersion;
