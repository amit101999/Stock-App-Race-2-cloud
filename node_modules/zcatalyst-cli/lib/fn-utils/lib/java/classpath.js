"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normaliseClasspath = exports.rewriteClasspath = void 0;
const path_1 = require("path");
const error_1 = __importDefault(require("../../../error"));
const fs_1 = require("../../../util_modules/fs");
const xml2js_1 = __importDefault(require("xml2js"));
const js_1 = require("../../../util_modules/js");
const ansi_colors_1 = require("ansi-colors");
const runtime_store_1 = __importDefault(require("../../../runtime-store"));
function rewriteClasspath(pth, libPth) {
    return __awaiter(this, void 0, void 0, function* () {
        yield fs_1.ASYNC.ensureDir(libPth);
        const content = yield fs_1.ASYNC.readFile(pth);
        if (content === undefined) {
            throw new error_1.default('Content of ' + pth + ' is not defined', { exit: 2 });
        }
        const files = yield fs_1.ASYNC.walk((0, path_1.dirname)(libPth), {
            filter: { exclude: ['**/.output'], excludeDir: true }
        });
        const result = yield xml2js_1.default.parseStringPromise(content);
        const classPathEntries = js_1.JS.chain(files)
            .filter((jar) => (0, path_1.extname)(jar.path) === '.jar')
            .map((jar) => {
            return {
                $: {
                    kind: 'lib',
                    path: (0, path_1.basename)((0, path_1.dirname)(jar.path)) === 'lib'
                        ? 'lib/' + (0, path_1.basename)(jar.path)
                        : (0, path_1.basename)(jar.path)
                }
            };
        })
            .concat(js_1.JS.get(result, 'classpath.classpathentry', []))
            .uniq()
            .value();
        js_1.JS.set(result, 'classpath.classpathentry', classPathEntries);
        const builder = new xml2js_1.default.Builder();
        return fs_1.ASYNC.writeFile(pth, builder.buildObject(result));
    });
}
exports.rewriteClasspath = rewriteClasspath;
function normaliseClasspath(pth, libFolder) {
    return __awaiter(this, void 0, void 0, function* () {
        const content = yield fs_1.ASYNC.readFile(pth);
        if (content === undefined) {
            throw new error_1.default('Content of ' + pth + ' is not defined', { exit: 2 });
        }
        const result = yield xml2js_1.default.parseStringPromise(content);
        const classPathEntries = js_1.JS.get(result, 'classpath.classpathentry', []);
        const jarFilesList = [];
        yield Promise.all(classPathEntries.map((entry) => __awaiter(this, void 0, void 0, function* () {
            const row = entry.$;
            if (row.kind && row.kind === 'lib' && row.path) {
                const libPath = (0, path_1.resolve)((0, path_1.dirname)(pth), row.path);
                const jarName = (0, path_1.basename)(libPath);
                const jarExists = yield fs_1.ASYNC.fileExists((0, path_1.join)(libFolder, jarName));
                if (!jarExists) {
                    try {
                        yield fs_1.ASYNC.copyFile(libPath, (0, path_1.join)(libFolder, jarName));
                    }
                    catch (err) {
                        throw new error_1.default(libPath + ' mentioned in .classpath file missing', {
                            exit: 1,
                            errorId: 'JAVA_CLS_PATH-1',
                            original: err,
                            arg: [(0, ansi_colors_1.bold)(libPath), (0, ansi_colors_1.bold)('.classpath')]
                        });
                    }
                }
                row.path = (0, path_1.basename)(libFolder) + '/' + jarName;
                if ((0, path_1.dirname)(libPath) === (0, path_1.dirname)(libFolder)) {
                    try {
                        yield fs_1.ASYNC.deleteFile(libPath);
                    }
                    catch (err) {
                        throw new error_1.default(libPath +
                            ' mentioned in .classpath file missing. The .classpath file in the target directory seems to be corrupted.', {
                            exit: 1,
                            errorId: 'JAVA_CLS_PATH-2',
                            original: err,
                            arg: [(0, ansi_colors_1.bold)('.classpath'), (0, ansi_colors_1.bold)((0, path_1.dirname)(pth))]
                        });
                    }
                }
                jarFilesList.push((0, path_1.join)(libFolder, jarName));
            }
        })));
        js_1.JS.set(result, 'classpath.classpathentry', classPathEntries);
        runtime_store_1.default.set('context.functions.java.libJarFiles', jarFilesList);
        const builder = new xml2js_1.default.Builder();
        return fs_1.ASYNC.writeFile(pth, builder.buildObject(result));
    });
}
exports.normaliseClasspath = normaliseClasspath;
