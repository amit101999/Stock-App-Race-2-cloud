"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isContainer = exports.isSocketAccessible = exports.showContainerUsagePrompt = void 0;
const ansi_colors_1 = require("ansi-colors");
const logger_1 = require("./logger");
const cli_table_1 = require("../cli_table");
const strip_ansi_1 = __importDefault(require("strip-ansi"));
const container_plugin_1 = require("@zcatalyst/container-plugin");
const error_1 = __importDefault(require("@zcatalyst/container-plugin/out/error"));
const userConfig_1 = __importStar(require("../userConfig"));
const error_2 = __importDefault(require("../error"));
function showContainerUsagePrompt() {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const headerText = 'Attention Developer !!!';
        const padding = Math.round((process.stdout.columns - headerText.length) / 2) - 2;
        const fillLen = padding + headerText.length + padding - 2;
        let isDocker;
        const _config = userConfig_1.default.get(userConfig_1.CONFIG_KEYS.serve_container);
        try {
            yield (0, container_plugin_1.ping)(true);
            isDocker = 2;
        }
        catch (er) {
            if (!(er instanceof error_1.default)) {
                (0, logger_1.debug)('Unknown error: ', er);
                return;
            }
            if (((_a = er.original) === null || _a === void 0 ? void 0 : _a.code) === 'ECONNREFUSED') {
                isDocker = 1;
            }
            else if (((_b = er.original) === null || _b === void 0 ? void 0 : _b.code) === 'ENOENT') {
                isDocker = 0;
            }
            else {
                isDocker = -1;
            }
        }
        const wrapLine = (line) => {
            const words = line.match(/(\s*\S+\s*)/g) || [];
            let currentLine = '';
            const wrappedLines = [];
            let activeAnsi = '';
            words.forEach((word) => {
                word = word.replace('\t', '    ');
                const cleanWord = (0, strip_ansi_1.default)(word);
                const currentLen = (0, strip_ansi_1.default)(currentLine).length;
                if (currentLen + cleanWord.length > fillLen) {
                    wrappedLines.push(currentLine);
                    currentLine = activeAnsi + word;
                }
                else {
                    currentLine += word;
                }
                const ansiMatch = word.match(ansi_colors_1.ansiRegex);
                if ((ansiMatch === null || ansiMatch === void 0 ? void 0 : ansiMatch.length) === 1) {
                    activeAnsi = ansiMatch[0];
                }
            });
            if (currentLine !== '') {
                wrappedLines.push(currentLine);
            }
            return wrappedLines.join('\n');
        };
        const table = (0, cli_table_1.getCustomColourTable)(ansi_colors_1.yellow.dim, { style: { compact: true } });
        const addLine = (line, options) => {
            table.push([
                Object.assign({ content: wrapLine(line) }, options)
            ]);
        };
        table.push([
            {
                content: ansi_colors_1.yellow.bold(headerText),
                hAlign: 'center',
                vAlign: 'center',
                style: {
                    'padding-left': padding,
                    'padding-right': padding
                }
            }
        ]);
        addLine(ansi_colors_1.yellow.dim('='.repeat(fillLen)) + '\n', { hAlign: 'center' });
        addLine((0, ansi_colors_1.cyan)(`This version of ${(0, ansi_colors_1.bold)('ZCatalyst-CLI')} supports serving the ${(0, ansi_colors_1.bold)('Catalyst Functions')} and ${(0, ansi_colors_1.bold)('Catalyst AppSail')} using ${(0, ansi_colors_1.bold)('Containers')}\n`), {
            hAlign: 'center'
        });
        addLine('To start using containers for Catalyst serve please follow the below steps:\n');
        addLine(`${ansi_colors_1.bold.magenta('Step-1:')} Install Docker to your machine\n`);
        if (isDocker === 0) {
            addLine('  Please follow the docs from the below links to install the Container runtime of your choice: ');
            addLine(`    ${(0, ansi_colors_1.bold)('Docker:')} ${ansi_colors_1.underline.blue('https://docs.docker.com/engine/install/')}`);
        }
        else {
            addLine(`  ${logger_1.CHAR.success} ${ansi_colors_1.bold.green('Done')}\n`);
        }
        addLine(`${ansi_colors_1.bold.magenta('Step-2:')} Start the Docker Container runtime\n`);
        if (isDocker !== 2) {
            addLine('  Please ensure the Docker container runtime is started and running properly');
            addLine('  To check you can use the below commands');
            addLine((0, ansi_colors_1.italic)(`    docker ps ${(0, ansi_colors_1.dim)('#check docker')}`));
        }
        else {
            addLine(`  ${logger_1.CHAR.success} ${ansi_colors_1.bold.green('Done')}\n`);
        }
        addLine(`${ansi_colors_1.bold.magenta('Step-3:')} Configure ZCatalyst-CLI to use Containers\n`);
        if (_config === 'true') {
            addLine(`  ${logger_1.CHAR.success} ${ansi_colors_1.bold.green('Done')}\n`);
        }
        else {
            addLine('  Execute the below command to configure ZCatalyst-CLI');
            addLine((0, ansi_colors_1.italic)(`    catalyst config:set serve.container=true ${(0, ansi_colors_1.dim)('#global config to use container')}`));
        }
        addLine(ansi_colors_1.yellow.dim('='.repeat(fillLen)) + '\n', { hAlign: 'center' });
        addLine(ansi_colors_1.bold.magenta('Note:'));
        addLine('  If you would like to stop seeing this message. You can configure the ZCatalyst-CLI to stop trying to use containers during serve using the below methods');
        addLine((0, ansi_colors_1.italic)(`    catalyst serve --no-container ${(0, ansi_colors_1.dim)('#disable only for a single serve command')}`));
        addLine((0, ansi_colors_1.italic)(`    catalyst config:delete serve.container ${(0, ansi_colors_1.dim)('#disable globally forever')}`));
        (0, logger_1.info)('\n' + table.toString());
    });
}
exports.showContainerUsagePrompt = showContainerUsagePrompt;
function isSocketAccessible(throwErr = true) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(yield (0, container_plugin_1.ping)(false))) {
            const error = new error_2.default('Docker socket not accessible', {
                exit: 1,
                errorId: 'CONTAINER-1',
                arg: [(0, ansi_colors_1.bold)('ZC_DOCKER_SOCK_PATH')]
            });
            if (throwErr) {
                throw error;
            }
            return false;
        }
        return true;
    });
}
exports.isSocketAccessible = isSocketAccessible;
function isContainer() {
    return false;
}
exports.isContainer = isContainer;
