'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.plugin = exports.script = exports.targets = exports.ignore = exports.source = void 0;
const path_1 = require("path");
const index_js_1 = __importDefault(require("../../../error/index.js"));
const runtime_store_1 = __importDefault(require("../../../runtime-store"));
const constants_1 = require("../../constants");
const js_1 = require("../../js");
const project_js_1 = require("../../project.js");
function getRawTargets() {
    const functionConfig = raw();
    if (functionConfig && (functionConfig === null || functionConfig === void 0 ? void 0 : functionConfig.targets)) {
        return functionConfig === null || functionConfig === void 0 ? void 0 : functionConfig.targets;
    }
    return [];
}
function getMatchingTarget(sourcePath) {
    const rawTargetArr = getRawTargets();
    const matchTargets = rawTargetArr.filter((target) => {
        if (typeof target === 'string') {
            return false;
        }
        if (target.source) {
            return sourcePath.endsWith(target.source);
        }
        return false;
    });
    if (matchTargets.length > 0) {
        return matchTargets[0];
    }
    return;
}
function raw(throwError = false) {
    const config = runtime_store_1.default.get('config', null);
    if (config === null) {
        if (throwError) {
            throw new index_js_1.default(constants_1.FILENAME.config + ' file is required', { exit: 2 });
        }
        return;
    }
    return config.get('functions');
}
function source(fallback = constants_1.FOLDERNAME.functions) {
    const functionsConfig = raw();
    const pth = (functionsConfig === null || functionsConfig === void 0 ? void 0 : functionsConfig.source) || fallback;
    const resolvedSource = (0, project_js_1.resolveProjectPath)(pth);
    if (!resolvedSource.startsWith((0, project_js_1.getProjectRoot)())) {
        throw new index_js_1.default('Invalid source path for client. Source path outside project root', {
            exit: 1,
            context: {
                projectRoot: (0, project_js_1.getProjectRoot)(),
                sourcePath: pth,
                resolvedSource
            }
        });
    }
    return resolvedSource;
}
exports.source = source;
function ignore(sourcePath) {
    let matchTarget;
    if (sourcePath) {
        matchTarget = getMatchingTarget(sourcePath);
    }
    let ignoreArr = [];
    if (matchTarget && matchTarget.ignore) {
        ignoreArr = matchTarget.ignore;
    }
    else {
        const functionConfig = raw();
        ignoreArr = (functionConfig && functionConfig.ignore) || [];
    }
    return ignoreArr.map((value) => {
        if (js_1.JS.indexOf(value, path_1.sep) === js_1.JS.size(value) - 1) {
            return '**' + path_1.sep + js_1.JS.initial(value).join('');
        }
        if (js_1.JS.startsWith(value, path_1.sep)) {
            return js_1.JS.endsWith(value, path_1.sep)
                ? sourcePath + js_1.JS.initial(value).join('')
                : sourcePath + value;
        }
        return js_1.JS.endsWith(value, path_1.sep)
            ? sourcePath + path_1.sep + js_1.JS.initial(value).join('')
            : sourcePath + path_1.sep + value;
    });
}
exports.ignore = ignore;
function targets(fallback) {
    const rawTargetArr = getRawTargets();
    if (rawTargetArr === null) {
        if (fallback === undefined) {
            throw new index_js_1.default('Function targets array is empty.', { exit: 2 });
        }
        return fallback;
    }
    return rawTargetArr.map((targetVal) => {
        if (typeof targetVal !== 'string') {
            throw new index_js_1.default('Invalid target value: ' + targetVal, { exit: 1 });
        }
        if (targetVal.includes(path_1.sep)) {
            throw new index_js_1.default(`Invalid target: "${targetVal}" should not contain a path.`, {
                exit: 1
            });
        }
        return targetVal;
    });
}
exports.targets = targets;
function script(name, fallback, sourcePath) {
    let matchTarget;
    if (sourcePath) {
        matchTarget = getMatchingTarget(sourcePath);
    }
    let rawScripts;
    if (matchTarget && matchTarget.scripts) {
        rawScripts = matchTarget.scripts;
    }
    else {
        const functionConfig = raw();
        rawScripts = functionConfig && (functionConfig === null || functionConfig === void 0 ? void 0 : functionConfig.scripts);
    }
    if (rawScripts === undefined && fallback === undefined) {
        throw new index_js_1.default('Scripts not found', { exit: 2 });
    }
    if (name === undefined) {
        return rawScripts || fallback;
    }
    if (rawScripts && rawScripts[name] === undefined && fallback === undefined) {
        throw new index_js_1.default('Scripts not found', { exit: 2 });
    }
    return (rawScripts && rawScripts[name]) || fallback;
}
exports.script = script;
function plugin(name, sourcePath) {
    let matchTarget;
    if (sourcePath) {
        matchTarget = getMatchingTarget(sourcePath);
    }
    let rawPlugins;
    if (matchTarget && matchTarget.plugin) {
        rawPlugins = matchTarget.plugin;
    }
    else {
        const functionConfig = raw();
        rawPlugins = functionConfig && functionConfig.plugin;
    }
    if (!rawPlugins) {
        return;
    }
    if (typeof rawPlugins === 'string') {
        if (name === undefined) {
            return {
                validate: rawPlugins,
                start: rawPlugins,
                build: rawPlugins
            };
        }
        return rawPlugins;
    }
    if (name === undefined) {
        return rawPlugins;
    }
    return rawPlugins && rawPlugins[name];
}
exports.plugin = plugin;
