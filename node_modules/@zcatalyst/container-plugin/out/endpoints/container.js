"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RUOK = void 0;
exports.createServerContainer = createServerContainer;
exports.ruok = ruok;
exports.stopContainer = stopContainer;
const api_1 = __importDefault(require("./api"));
const error_1 = __importDefault(require("../error"));
const logger_1 = __importDefault(require("../logger"));
const dns_1 = require("dns");
const utils_1 = require("../utils");
const http_1 = require("http");
const constants_1 = require("../constants");
/** RUOK retry values */
var RUOK;
(function (RUOK) {
    /** Finite number of RUOK calls to the container. Max 50 calls */
    RUOK[RUOK["INFINITE"] = -1] = "INFINITE";
    /** No upper limit on the number of RUOK calls */
    RUOK[RUOK["FINITE"] = 0] = "FINITE";
    /** Skip RUOK call altogether */
    RUOK[RUOK["SKIP"] = 1] = "SKIP";
})(RUOK || (exports.RUOK = RUOK = {}));
/**
 * Create a Catalyst serve container
 * @param Options Options for the serve container
 * @returns Promise that resolves to {@link Container}
 */
function createServerContainer(_a) {
    return __awaiter(this, arguments, void 0, function* ({ name, image, envVars, command, volumes, cwd, httpPort, debugPort }) {
        var _b, _c, _d, _e, _f;
        // add bin to path env var at first so user env vars can override if needed
        envVars.unshift('PATH=/var/lang/bin:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin');
        const containerConfig = {
            name,
            WorkingDir: cwd,
            Env: envVars,
            Image: image,
            // Tty: true, // uncomment this line to make the container not quit
            HostConfig: {
                Binds: [],
                Dns: (0, dns_1.getServers)(),
                ExtraHosts: ['host.docker.internal:host-gateway']
            },
            Cmd: command // comment this line to make the container not quit
        };
        // mount user code volume and runtime if available
        if (volumes === null || volumes === void 0 ? void 0 : volumes.codeLocation) {
            if (!((_b = containerConfig.HostConfig) === null || _b === void 0 ? void 0 : _b.Binds)) {
                throw new error_1.default('Unable to bind runtime: Invalid host config', {
                    context: containerConfig
                });
            }
            if (!containerConfig.Volumes) {
                containerConfig.Volumes = {};
            }
            containerConfig.Volumes['/catalyst'] = {};
            containerConfig.Volumes['/var/lang'] = {};
            containerConfig.HostConfig.Binds.push(`${volumes.codeLocation}:/catalyst`, `${volumes.lang}:/var/lang:ro`);
        }
        // mount runtimes volume if available
        if (volumes === null || volumes === void 0 ? void 0 : volumes.runtime) {
            if (!((_c = containerConfig.HostConfig) === null || _c === void 0 ? void 0 : _c.Binds)) {
                throw new error_1.default('Unable to bind runtime: Invalid host config', {
                    context: containerConfig
                });
            }
            if (!containerConfig.Volumes) {
                containerConfig.Volumes = {};
            }
            containerConfig.Volumes['/var/runtime'] = {};
            containerConfig.HostConfig.Binds.push(`${volumes.runtime}:/var/runtime:ro`);
        }
        // bind external http port to container http port (default 9000) if applicable
        if ((httpPort === null || httpPort === void 0 ? void 0 : httpPort.host) && httpPort.host !== -1) {
            const containerPort = httpPort.container && httpPort.container !== -1
                ? `${httpPort.container}/tcp`
                : '9000/tcp';
            containerConfig.ExposedPorts = {
                [containerPort]: {}
            };
            if (!containerConfig.HostConfig) {
                throw new error_1.default('Invalid host config: config not present');
            }
            containerConfig.HostConfig.PortBindings = {
                [containerPort]: [
                    {
                        HostIp: '127.0.0.1',
                        HostPort: httpPort.host + ''
                    }
                ]
            };
        }
        else {
            logger_1.default.debug(`Host HTTP port is invalid (${httpPort === null || httpPort === void 0 ? void 0 : httpPort.host}) for container: ${name}`);
        }
        // bind external debug port to container debug port(default 9100) if applicable
        if ((debugPort === null || debugPort === void 0 ? void 0 : debugPort.host) && debugPort.host !== -1) {
            if (!containerConfig.ExposedPorts) {
                containerConfig.ExposedPorts = {};
            }
            const containerPort = debugPort.container && debugPort.container !== -1
                ? `${debugPort.container}/tcp`
                : '9100/tcp';
            containerConfig.ExposedPorts[containerPort] = {};
            if (!containerConfig.HostConfig) {
                throw new error_1.default('Invalid host config: config not present');
            }
            if (!containerConfig.HostConfig.PortBindings) {
                containerConfig.HostConfig.PortBindings = {};
            }
            containerConfig.HostConfig.PortBindings[containerPort] = [
                {
                    HostIp: '127.0.0.1',
                    HostPort: debugPort.host + ''
                }
            ];
        }
        else {
            logger_1.default.debug(`Host DEBUG port is invalid (${debugPort === null || debugPort === void 0 ? void 0 : debugPort.host}) for container: ${name}`);
        }
        // remove container if already present with the same name
        const isContainer = yield api_1.default.listContainers({
            all: true,
            filters: {
                name: [name]
            }
        });
        if (isContainer.at(0) && ((_d = isContainer.at(0)) === null || _d === void 0 ? void 0 : _d.Names.includes('/' + containerConfig.name))) {
            const id = ((_e = isContainer.at(0)) === null || _e === void 0 ? void 0 : _e.Id) || '';
            const _cont = api_1.default.getContainer(id);
            logger_1.default.debug(`Container with the name ${containerConfig.name} already found with ContainerId: ${id}`);
            if (isContainer.at(0) && ((_f = isContainer.at(0)) === null || _f === void 0 ? void 0 : _f.State) !== 'Exited') {
                logger_1.default.debug(`Trying to stop a container with Id: ${id}`);
                yield _cont
                    .stop()
                    .catch((er) => logger_1.default.debug(`Error stopping the container with Id [${id}]: ${er.toString()}`));
                logger_1.default.debug(`Trying to remove a container with Id: ${id}`);
            }
            yield _cont
                .remove()
                .catch((er) => logger_1.default.debug(`Error removing the container with Id [${id}]: ${er.toString()}`));
        }
        return api_1.default.createContainer(containerConfig);
    });
}
/**
 * Get ruok signal from the function container
 * @param targetDetails details of the function target
 * @param maxItr maximum number of retries
 * @param
 * @returns Promise that resolves if the ruok response is 200
 */
function ruok(targetDetails_1) {
    return __awaiter(this, arguments, void 0, function* (targetDetails, maxItr = 50) {
        return _ruok(targetDetails, maxItr);
    });
}
const BACKOFF_FACTOR = 1.21; // should be > 1. Fixed as 1.21 as it produces more random values within the acceptable range of 0 to 10000
const BASE_DELAY = 100;
const MAX_DELAY = 10000; // 10 s
function _ruok(targetDetails_1) {
    return __awaiter(this, arguments, void 0, function* (targetDetails, maxItr = 50, itr = 0) {
        if (itr > maxItr) {
            throw new error_1.default('Unable to start the server');
        }
        try {
            yield ruokAPI(targetDetails.httpPort);
        }
        catch (er) {
            const _er = er;
            if (_er.code === 'ECONNREFUSED' || _er.code === 'ECONNRESET') {
                const sleepTime = (Math.random() / BASE_DELAY) * BASE_DELAY * BACKOFF_FACTOR ** (itr - 1);
                yield (0, utils_1.sleep)(Math.min(sleepTime, MAX_DELAY));
                return _ruok(targetDetails, maxItr, ++itr);
            }
            throw new error_1.default('Unable to start the server: ' + er);
        }
    });
}
/**
 * Api implementation of ruok
 * @param port host port to which the ruok api should be hit
 * @returns Promise that resolves with the response of 200
 */
function ruokAPI(port) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((res, rej) => {
            if (typeof port !== 'number') {
                throw new error_1.default('Port value not a number: ', port);
            }
            (0, http_1.get)(`http://127.0.0.1:${port}/ruok`, {
                headers: {
                    'x-zoho-catalyst-internal': 'true',
                    'x-zc-instance-id': 'local'
                }
            }, (resp) => {
                if (resp.statusCode === 200) {
                    res();
                    return;
                }
                rej(resp.statusCode);
            }).on('error', (er) => rej(er));
        });
    });
}
function stopContainer(container) {
    return __awaiter(this, void 0, void 0, function* () {
        const waitPromise = new Promise((resolve) => {
            container.wait((_, exit) => resolve({ statusCode: exit === null || exit === void 0 ? void 0 : exit.StatusCode, error: exit === null || exit === void 0 ? void 0 : exit.Error }));
        });
        logger_1.default.debug('Closing ::: trying to stop container with Id: ' + container.id);
        yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            let stop = false;
            const containerStopPromise = container.stop({ signal: 'SIGTERM' }).then(() => {
                stop = true;
                resolve();
            }).catch((err) => {
                if (err.statusCode !== 304 && err.statusCode !== 404) {
                    logger_1.default.debug(`Closing ::: Error stopping the container ::: ${err.message}`);
                    reject(err);
                    return;
                }
                resolve();
            });
            // start timeout
            const graceTimeout = setTimeout(() => {
                if (!stop) {
                    logger_1.default.debug('Closing ::: Grace time exceeded, stopping the container with SIGKILL');
                    container.stop({ signal: 'SIGKILL' }).catch((err) => {
                        if (err.statusCode !== 304 && err.statusCode !== 404) {
                            logger_1.default.debug(`Closing ::: Error stopping the container with SIGKILL ::: ${err.message}`);
                            reject(err);
                            return;
                        }
                        resolve();
                    }).then(resolve);
                }
            }, constants_1.TIMEOUTS.exit);
            containerStopPromise.then(() => {
                clearTimeout(graceTimeout); // clear timeout if the stop promise resolves
            });
        }));
        const { statusCode, error } = yield waitPromise;
        const inspect = statusCode !== undefined ? yield container.inspect() : undefined;
        return { inspect, statusCode, error };
    });
}
