"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllLocalImages = getAllLocalImages;
exports.findImageInLocal = findImageInLocal;
exports.loadImageFromStream = loadImageFromStream;
exports.loadImage = loadImage;
exports.loadTempImageTar = loadTempImageTar;
exports.inspectImage = inspectImage;
exports.removeImages = removeImages;
exports.packImage = packImage;
exports.getTarEntry = getTarEntry;
const api_1 = __importDefault(require("./api"));
const error_1 = __importDefault(require("../error"));
const logger_1 = __importDefault(require("../logger"));
const utils_1 = require("../utils");
const os = __importStar(require("os"));
const path_1 = require("path");
const tar = __importStar(require("tar"));
const promises_1 = require("fs/promises");
const stream_1 = require("stream");
/**
 * Get all images present in local
 * @param reference image name to search for (optional)
 * @returns
 */
function getAllLocalImages(reference) {
    return __awaiter(this, void 0, void 0, function* () {
        return reference
            ? api_1.default.listImages({
                filters: {
                    reference: [reference]
                }
            })
            : api_1.default.listImages();
    });
}
/**
 * Search and find if tht image is available in the local container registry
 * @param image image to be searched
 * @returns Promise that resolves to Image info if the image is found
 */
function findImageInLocal(image) {
    return __awaiter(this, void 0, void 0, function* () {
        const info = yield getAllLocalImages(image);
        return info === null || info === void 0 ? void 0 : info.at(0);
    });
}
function loadImageFromStream(stream) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            stream.on('error', (er) => {
                reject(new error_1.default('Error when downloading the image', {
                    original: er
                }));
            });
            stream.isPaused() && stream.resume();
            yield api_1.default.loadImage(stream).catch((er) => {
                reject(new error_1.default(`Error when loading image into container engine`, {
                    original: er
                }));
            });
            logger_1.default.debug('Image loaded successfully');
            logger_1.default.debug('');
            resolve();
        })).finally(() => 'destroy' in stream && stream.destroy());
    });
}
/**
 * Checks if the image is present in local repository, if not it'll try to download it from Stratus and load it to localhost.
 * @param image Image name
 * @returns Image details in local
 */
function loadImage(image_1, downloadUrl_1) {
    return __awaiter(this, arguments, void 0, function* (image, downloadUrl, update = false) {
        var _a, _b;
        if (!update) {
            const localImage = yield findImageInLocal(image);
            if (localImage) {
                logger_1.default.debug(`Found image for runtime ${image} in local: ${(_a = localImage.RepoTags) === null || _a === void 0 ? void 0 : _a.at(0)}`);
                return localImage;
            }
        }
        logger_1.default.debug('');
        logger_1.default.debug(`Image ${image} not found in local hence trying to download...`);
        logger_1.default.debug(`Image url: ${downloadUrl}`);
        logger_1.default.debug('');
        const imagesRes = yield (0, utils_1.getAsStream)(downloadUrl, `Downloading Image: ${image}`);
        // pipe stream to load image
        // await new Promise<void>(async (resolve, reject) => {
        // 	imagesRes.on('error', (er) => {
        // 		reject(
        // 			new CatalystPluginError('Error when downloading the image', {
        // 				original: er
        // 			})
        // 		);
        // 	});
        // 	imagesRes.isPaused() && imagesRes.resume();
        // 	await api.loadImage(imagesRes).catch((er) =>
        // 		reject(
        // 			new CatalystPluginError(`Error when loading ${image} into container engine`, {
        // 				original: er
        // 			})
        // 		)
        // 	);
        // 	LOGGER.debug('Image loaded successfully');
        // 	LOGGER.debug('');
        // 	resolve();
        // });
        yield loadImageFromStream(imagesRes);
        logger_1.default.debug('stream promise resolved');
        const loadedImage = yield findImageInLocal(image);
        if (!loadedImage) {
            logger_1.default.error('');
            logger_1.default.error(`The image ${image} is not pulled properly to localhost.`);
            logger_1.default.error(`Please download the image and load it manually using the "docker load" command`);
            logger_1.default.error(`Image download url: ${downloadUrl}`);
            logger_1.default.error('');
            throw new error_1.default(`Image(${image}) is not loaded properly`);
        }
        logger_1.default.debug('');
        logger_1.default.debug(`Image pull completed for runtime ${image}: ${(_b = loadedImage.RepoTags) === null || _b === void 0 ? void 0 : _b.at(0)}`);
        return loadedImage;
    });
}
function loadTempImageTar(name, stream) {
    return __awaiter(this, void 0, void 0, function* () {
        const tempDir = (0, path_1.join)(os.tmpdir(), '.catalyst');
        const tempTarDir = (0, path_1.join)(tempDir, 'temp-image-' + name);
        yield (0, utils_1.ensureDir)(tempTarDir);
        const tempImgName = `localhost/catalyst/${name}:temp`.toLowerCase();
        const tarEntries = new Set();
        try {
            // un-tar to local directory
            // TODO: check if instead of un-tar and updating the manifest, can the manifest be updated on the go
            const _tar = tar.x({
                cwd: tempTarDir,
                onReadEntry: (entry) => {
                    const _entry = entry.path.split(path_1.sep).at(0);
                    _entry !== undefined && tarEntries.add(_entry);
                }
            });
            yield new Promise((resolve, reject) => {
                stream.isPaused() && stream.resume();
                stream
                    .pipe(_tar)
                    .on('end', () => resolve(tempTarDir))
                    .on('error', (er) => reject(er));
            });
        }
        catch (er) {
            throw new error_1.default('Error while extracting the tar file', { context: er });
        }
        // read and change manifest.json
        try {
            const manifestPath = (0, path_1.join)(tempTarDir, 'manifest.json');
            const fileBuff = yield (0, promises_1.readFile)(manifestPath).catch((er) => {
                logger_1.default.error('Error while reading the manifest file: ' + er);
            });
            const manifestArr = fileBuff
                ? JSON.parse(fileBuff.toString())
                : undefined;
            const manifest = manifestArr === null || manifestArr === void 0 ? void 0 : manifestArr.at(0);
            if (!manifest) {
                throw new error_1.default('Invalid manifest file');
            }
            manifest.RepoTags = [tempImgName, ...(manifest.RepoTags || [])];
            yield (0, promises_1.writeFile)(manifestPath, JSON.stringify([manifest]));
        }
        catch (er) {
            throw new error_1.default('Error while manipulating the manifest file', {
                context: er
            });
        }
        // read and change index.json
        try {
            const indexJsonPath = (0, path_1.join)(tempTarDir, 'index.json');
            const fileBuff = yield (0, promises_1.readFile)(indexJsonPath).catch((er) => {
                if ('code' in er && er.code === 'ENOENT') {
                    logger_1.default.debug('Index file not found: ' + er);
                }
                else {
                    logger_1.default.error('Error reading the index.json file from the image: ' + er);
                }
            });
            const indexJson = fileBuff ? JSON.parse(fileBuff.toString()) : undefined;
            if (indexJson) {
                const manifest = indexJson.manifests.at(0);
                // manipulating the manifest in-place in the array, hence
                // object reassignment is not necessary
                if (manifest) {
                    manifest.annotations = Object.assign(Object.assign({}, (manifest.annotations || {})), { 'io.containerd.image.name': tempImgName, 'org.opencontainers.image.ref.name': 'temp' });
                }
            }
            yield (0, promises_1.writeFile)(indexJsonPath, JSON.stringify(indexJson));
        }
        catch (er) {
            throw new error_1.default('Error while manipulating the manifest file', {
                context: er
            });
        }
        // load the image
        try {
            const tempTarStream = new stream_1.PassThrough().pause();
            tar.c({ cwd: tempTarDir }, Array.from(tarEntries)).pipe(tempTarStream);
            yield loadImageFromStream(tempTarStream);
            const imageInfo = yield findImageInLocal(tempImgName);
            if (!imageInfo) {
                throw new error_1.default('Unable to find the image info for image tag: ' + tempImgName);
            }
            return imageInfo;
        }
        catch (er) {
            throw new error_1.default('Error while loading the image', { context: er });
        }
        finally {
            yield (0, utils_1.deletePath)(tempTarDir);
        }
    });
}
function inspectImage(image) {
    return __awaiter(this, void 0, void 0, function* () {
        return api_1.default.getImage(image).inspect();
    });
}
/**
 * Remove image from the local container registry
 * @param prefix Image to be removed
 * @returns Promise that resolves to an Array of removed images
 */
function removeImages(prefix) {
    return __awaiter(this, void 0, void 0, function* () {
        const info = yield getAllLocalImages(prefix);
        return Promise.all(info.map((img) => __awaiter(this, void 0, void 0, function* () {
            const image = api_1.default.getImage(img.Id);
            yield image.remove();
            return img;
        })));
    });
}
/**
 * Package a image as a tar
 * @param prefix to identify the image
 * @returns Promise that resolves to a stream of a tar file
 */
function packImage(prefix) {
    return __awaiter(this, void 0, void 0, function* () {
        return api_1.default.getImage(prefix).get();
    });
}
function getTarEntry(tarPath, entry) {
    return __awaiter(this, void 0, void 0, function* () {
        return typeof entry === 'function'
            ? tar
                .t({
                file: tarPath,
                onReadEntry: entry
            })
                .catch((er) => {
                throw er instanceof Error
                    ? er
                    : new error_1.default('Error while reading the tar entries');
            })
            : new Promise((resolve, reject) => {
                tar.t({
                    file: tarPath,
                    onReadEntry: (_entry) => {
                        if (_entry.path === entry) {
                            const passThrough = new stream_1.PassThrough();
                            resolve(passThrough);
                            _entry.pipe(passThrough);
                        }
                    }
                })
                    .catch((er) => reject(er instanceof Error
                    ? er
                    : new error_1.default('Error while reading the tar entries')))
                    .then(resolve);
            });
    });
}
