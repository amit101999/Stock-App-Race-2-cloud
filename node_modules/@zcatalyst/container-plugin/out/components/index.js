"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureComponents = ensureComponents;
exports.getLocalComponentPath = getLocalComponentPath;
const image_1 = require("../endpoints/image");
const utils_1 = require("../utils");
const logger_1 = __importDefault(require("../logger"));
const tar = __importStar(require("tar"));
const path_1 = require("path");
const constants_1 = require("../constants");
const promises_1 = require("fs/promises");
const error_1 = __importDefault(require("../error"));
const lock_1 = require("./lock");
const component_map_1 = require("./component-map");
const DownloadLock = new lock_1.SimpleLock();
/**
 * Ensure the latest components to server a function or appsail within a container is present
 * in the local machine.
 *
 * Components includes:
 * * `RootFS`     - Container image with required OS and tools, directly loaded to the container runtime.
 * * `LangBinary` - Language specific binary executables. Present in global config dir and mounted to `/var/lang`
 * * `Runtime`    - Runtime code for Catalyst functions. Present in global config dir and mounted to `/var/runtime`
 *
 * @param components specific container components to be ensured
 * @returns Promise that returns the path to local components
 */
function ensureComponents(_a) {
    return __awaiter(this, arguments, void 0, function* ({ rootFs, lang, runtime }) {
        // ensure rootFs
        let updated = false;
        const componentPaths = {};
        const rootFsName = (0, component_map_1.getRootFsName)(rootFs || '');
        if (rootFsName) {
            const localRootFs = yield component_map_1.ComponentMap.local.getRootFs(rootFsName, false);
            const remoteRootFs = yield component_map_1.ComponentMap.remote.getRootFs(rootFsName);
            const rootFsImage = `localhost/zcatalyst/guest-${rootFsName}`;
            if (remoteRootFs && (localRootFs === null || localRootFs === void 0 ? void 0 : localRootFs.fingerprint) !== remoteRootFs.fingerprint) {
                if (DownloadLock.getLock(rootFsImage)) {
                    // LOGGER.info('Updating root_fs image for: ' + rootFs);
                    logger_1.default.debug(`Initiating: Updating image ::: ${rootFsImage} ::: ${remoteRootFs.download_url}`);
                    yield (0, image_1.loadImage)(rootFsImage, remoteRootFs === null || remoteRootFs === void 0 ? void 0 : remoteRootFs.download_url, true).finally(() => DownloadLock.releaseLock(rootFsImage));
                    logger_1.default.debug(`Success: Updating image ::: ${rootFsImage} ::: ${remoteRootFs.download_url}`);
                    updated = true;
                }
                else {
                    yield DownloadLock.waitRelease(rootFsImage);
                }
                // LOGGER.info();
            }
            else {
                if (DownloadLock.getLock(rootFsImage)) {
                    logger_1.default.debug(`Initiating: Loading image ::: ${rootFsImage} ::: ${remoteRootFs === null || remoteRootFs === void 0 ? void 0 : remoteRootFs.download_url}`);
                    if (!(remoteRootFs === null || remoteRootFs === void 0 ? void 0 : remoteRootFs.download_url)) {
                        throw new error_1.default('Invalid download_url for ' + rootFsName, {
                            context: remoteRootFs
                        });
                    }
                    yield (0, image_1.loadImage)(rootFsImage, remoteRootFs === null || remoteRootFs === void 0 ? void 0 : remoteRootFs.download_url).finally(() => DownloadLock.releaseLock(rootFsImage));
                    logger_1.default.debug(`Success: Loading image ::: ${rootFsImage} ::: ${remoteRootFs.download_url}`);
                }
                else {
                    yield DownloadLock.waitRelease(rootFsImage);
                }
            }
            componentPaths.rootFs = rootFsImage;
        }
        // ensure lang binary
        if (lang) {
            const localLangBin = yield component_map_1.ComponentMap.local.getLang(lang, false);
            const remoteLangBin = yield component_map_1.ComponentMap.remote.getLang(lang);
            const langBinName = `${lang}-lang`;
            const localLanBinPath = (0, path_1.join)(constants_1.LOCAL_COMPONENTS_PATH, constants_1.PATHS.lang, langBinName);
            if (remoteLangBin && (localLangBin === null || localLangBin === void 0 ? void 0 : localLangBin.fingerprint) !== remoteLangBin.fingerprint) {
                if (DownloadLock.getLock(remoteLangBin.download_url)) {
                    // LOGGER.info('Updating language binary for: ' + lang);
                    logger_1.default.debug(`Initiating: Updating lang bin ::: ${langBinName} ::: ${remoteLangBin.download_url}`);
                    yield downloadComponent(remoteLangBin.download_url, localLanBinPath, `Updating Lang bin: ${lang} `).finally(() => DownloadLock.releaseLock(remoteLangBin.download_url));
                    logger_1.default.debug(`Success: Updating lang bin ::: ${langBinName} ::: ${remoteLangBin.download_url}`);
                    // LOGGER.info();
                    updated = true;
                }
                else {
                    yield DownloadLock.waitRelease(remoteLangBin.download_url);
                }
            }
            else if (remoteLangBin && !(yield (0, utils_1.isDir)(localLanBinPath))) {
                if (DownloadLock.getLock(remoteLangBin.download_url)) {
                    // LOGGER.info('Downloading language binary for: ' + lang);
                    logger_1.default.debug(`Initiating: Downloading lang bin ::: ${langBinName} ::: ${remoteLangBin === null || remoteLangBin === void 0 ? void 0 : remoteLangBin.download_url}`);
                    if (!(remoteLangBin === null || remoteLangBin === void 0 ? void 0 : remoteLangBin.download_url)) {
                        throw new error_1.default('Invalid download_url for ' + lang, {
                            context: remoteLangBin
                        });
                    }
                    yield downloadComponent(remoteLangBin.download_url, localLanBinPath, `Downloading Lang bin: ${lang} `).finally(() => DownloadLock.releaseLock(remoteLangBin.download_url));
                    logger_1.default.debug(`Success: Downloading lang bin ::: ${langBinName} ::: ${remoteLangBin.download_url}`);
                    updated = true;
                    // LOGGER.info();
                }
                else {
                    yield DownloadLock.waitRelease(remoteLangBin.download_url);
                }
            }
            componentPaths.lang = localLanBinPath;
        }
        const runtimeName = `${runtime}-runtime`;
        const localRuntimePath = (0, path_1.join)(constants_1.LOCAL_COMPONENTS_PATH, constants_1.PATHS.runtime, runtimeName);
        if (runtime) {
            // TODO: ensure runtime
            const localRuntime = yield component_map_1.ComponentMap.local.getRuntime(runtime, false);
            const remoteRuntime = yield component_map_1.ComponentMap.remote.getRuntime(runtime);
            if (remoteRuntime && (localRuntime === null || localRuntime === void 0 ? void 0 : localRuntime.fingerprint) !== remoteRuntime.fingerprint) {
                if (DownloadLock.getLock(remoteRuntime.download_url)) {
                    logger_1.default.debug(`Initiating: Updating runtime ::: ${runtimeName} ::: ${remoteRuntime.download_url}`);
                    yield downloadComponent(remoteRuntime.download_url, localRuntimePath, `Updating Runtime: ${runtime}`).finally(() => DownloadLock.releaseLock(remoteRuntime.download_url));
                    logger_1.default.debug(`Success: Updating runtime ::: ${runtimeName} ::: ${remoteRuntime.download_url}`);
                    updated = true;
                    // LOGGER.info();
                }
                else {
                    yield DownloadLock.waitRelease(remoteRuntime.download_url);
                }
            }
            else if (remoteRuntime && !(yield (0, utils_1.isDir)(localRuntimePath))) {
                if (DownloadLock.getLock(remoteRuntime.download_url)) {
                    logger_1.default.debug(`Initiating: Downloading runtime ::: ${runtimeName} ::: ${remoteRuntime === null || remoteRuntime === void 0 ? void 0 : remoteRuntime.download_url}`);
                    if (!(remoteRuntime === null || remoteRuntime === void 0 ? void 0 : remoteRuntime.download_url)) {
                        throw new error_1.default('Invalid download_url for ' + runtime, {
                            context: remoteRuntime
                        });
                    }
                    yield downloadComponent(remoteRuntime.download_url, localRuntimePath, `Downloading Runtime: ${runtime}`).finally(() => DownloadLock.releaseLock(remoteRuntime.download_url));
                    logger_1.default.debug(`Success: Downloading runtime ::: ${runtimeName} ::: ${remoteRuntime.download_url}`);
                    updated = true;
                    // LOGGER.info();
                }
                else {
                    yield DownloadLock.waitRelease(remoteRuntime.download_url);
                }
            }
            componentPaths.runtime = localRuntimePath;
        }
        if (updated) {
            // write the info json to local
            const infoFilePath = (0, path_1.join)(constants_1.LOCAL_COMPONENTS_PATH, constants_1.PATHS.info);
            logger_1.default.debug(`Initiating: Updating local info with remote info ::: ${infoFilePath}`);
            const allComponents = yield component_map_1.ComponentMap.remote.getAllComponents();
            yield (0, promises_1.writeFile)(infoFilePath, JSON.stringify({
                root_fs: allComponents.rootFs,
                lang: allComponents.lang,
                runtime: allComponents.runtime
            }));
            logger_1.default.debug(`Success: Updating local info with remote info ::: ${infoFilePath}`);
        }
        return getLocalComponentPath(componentPaths);
    });
}
/**
 * Downloads the tar from the URL and extract to a path
 * @param url downloadable url of the component
 * @param path storage path
 *
 * @returns Promise that resolves to the local storage path of the component
 */
function downloadComponent(url, path, label) {
    return __awaiter(this, void 0, void 0, function* () {
        logger_1.default.debug('downloading component form url: ' + url);
        const tarStream = yield (0, utils_1.getAsStream)(url, label);
        if (!(yield (0, utils_1.isDir)(path))) {
            logger_1.default.debug('Creating new directory in the path :: ' + path);
            yield (0, promises_1.mkdir)(path, { recursive: true });
        }
        const _tar = tar.x({ cwd: path });
        const tarPromise = new Promise((resolve, reject) => {
            tarStream.isPaused() && tarStream.resume();
            tarStream
                .pipe(_tar)
                .on('end', () => resolve(path))
                .on('error', (er) => reject(er));
        });
        tarPromise.then(() => logger_1.default.debug('Successfully downloaded component to: ' + path));
        return tarPromise;
    });
}
/**
 * Get the Local Component Path for a stack, like java8, node10, python_3_9 etc.
 *
 * Note: The returned component paths does not work for browser_logic and AppSail war as they require
 * a different set of rootFs and runtime than usual. For this case get the local components path by
 * using {@link ensureComponents}
 *
 * @param key component for which the path should be fetched
 * @returns
 */
function getLocalComponentPath(key) {
    return typeof key === 'string'
        ? {
            rootFsImage: `localhost/zcatalyst/guest-${(0, component_map_1.getRootFsName)(key)}:latest`,
            lang: (0, path_1.join)(constants_1.LOCAL_COMPONENTS_PATH, constants_1.PATHS.lang, `${key}-lang`),
            runtime: (0, path_1.join)(constants_1.LOCAL_COMPONENTS_PATH, constants_1.PATHS.runtime, `${key}-runtime`)
        }
        : {
            rootFsImage: key.rootFs,
            lang: key.lang,
            runtime: key.runtime ? key.runtime : ''
        };
}
