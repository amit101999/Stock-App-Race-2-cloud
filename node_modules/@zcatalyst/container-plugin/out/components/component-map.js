"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _ContainerComponents_instances, _ContainerComponents_getData;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComponentMap = exports.ContainerComponents = exports.RootFsRuntimeMap = void 0;
exports.getRootFsName = getRootFsName;
const https_1 = require("https");
const error_1 = __importDefault(require("../error"));
const constants_1 = require("../constants");
const path_1 = require("path");
const promises_1 = require("fs/promises");
/** Hardcoded info.json url */
const componentsJsonUrl = 'https://zc-dx-public-development.zohostratus.com/containers/info.json';
/**
 * Map of the stack/key and the related rootFs to be used
 */
exports.RootFsRuntimeMap = {
    // java
    java8: 'alpine',
    java11: 'ubuntu',
    java17: 'ubuntu',
    // node
    node10: 'alpine',
    node12: 'alpine',
    node14: 'alpine',
    node16: 'alpine',
    node18: 'ubuntu',
    node20: 'ubuntu',
    // python
    python_3_9: 'ubuntu',
    // browser_logic
    browser_logic: 'chrome'
};
/**
 * Utility to get the related rootFs name based on the key
 * @param key Key to which the rootFs to be fetched
 * @returns Name of the rootFs for the key
 */
function getRootFsName(key) {
    return exports.RootFsRuntimeMap[key];
}
/**
 * Utility that holds the details of Catalyst container components
 */
class ContainerComponents {
    constructor(env) {
        _ContainerComponents_instances.add(this);
        this.env = env;
    }
    /**
     * Get the rootFs value for the key
     * @param key key for which the rootFs value should be found
     * @param throwErr config which decides whether to throw if any error is encountered
     * @returns Promise that resolves to rootFs component details
     */
    getRootFs(key_1) {
        return __awaiter(this, arguments, void 0, function* (key, throwErr = true) {
            if (!this.rootFs) {
                yield __classPrivateFieldGet(this, _ContainerComponents_instances, "m", _ContainerComponents_getData).call(this);
            }
            const rootFs = this.rootFs ? this.rootFs[key] : undefined;
            if (!rootFs) {
                if (throwErr)
                    throw new error_1.default('Invalid rootFs value');
                return;
            }
            return rootFs;
        });
    }
    /**
     * Get the Language binary value for the key
     * @param key key for which the Language binary value should be found
     * @param throwErr config which decides whether to throw if any error is encountered
     * @returns Promise that resolves to Language binary component details
     */
    getLang(key_1) {
        return __awaiter(this, arguments, void 0, function* (key, throwErr = true) {
            if (!this.lang) {
                yield __classPrivateFieldGet(this, _ContainerComponents_instances, "m", _ContainerComponents_getData).call(this);
            }
            const lang = this.lang ? this.lang[key] : undefined;
            if (!lang) {
                if (throwErr)
                    throw new error_1.default('Invalid lang value');
                return;
            }
            return lang;
        });
    }
    /**
     * Get the runtime value for the key
     * @param key key for which the runtime value should be found
     * @param throwErr config which decides whether to throw if any error is encountered
     * @returns Promise that resolves to runtime component details
     */
    getRuntime(key_1) {
        return __awaiter(this, arguments, void 0, function* (key, throwErr = true) {
            if (!this.runtime) {
                yield __classPrivateFieldGet(this, _ContainerComponents_instances, "m", _ContainerComponents_getData).call(this);
            }
            const runtime = this.runtime ? this.runtime[key] : undefined;
            if (!runtime) {
                if (throwErr)
                    throw new error_1.default('Invalid runtime value');
                return;
            }
            return runtime;
        });
    }
    /**
     * Get the details of all the Catalyst container components available
     * @param key key which identifies the container components. Example 'java8' | 'node16' | 'python_3_9' | etc..
     * @returns Promise that resolves to the runtime details of the related Catalyst container components
     */
    getComponents(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                rootFs: yield this.getRootFs(key),
                lang: yield this.getLang(key),
                runtime: yield this.getRuntime(key)
            };
        });
    }
    /**
     * Get all the component details for the matching key
     * @returns Promise the resolves to details of all Catalyst container components
     */
    getAllComponents() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.rootFs || !this.lang || !this.runtime) {
                yield __classPrivateFieldGet(this, _ContainerComponents_instances, "m", _ContainerComponents_getData).call(this);
            }
            if (!this.rootFs || !this.lang || !this.runtime) {
                throw new error_1.default('Component details missing', {
                    context: {
                        rootFs: this.rootFs,
                        lang: this.lang,
                        runtime: this.runtime
                    }
                });
            }
            return {
                rootFs: this.rootFs,
                lang: this.lang,
                runtime: this.runtime
            };
        });
    }
}
exports.ContainerComponents = ContainerComponents;
_ContainerComponents_instances = new WeakSet(), _ContainerComponents_getData = function _ContainerComponents_getData() {
    return __awaiter(this, arguments, void 0, function* (env = this.env) {
        const mapJson = env === 'remote'
            ? yield new Promise((resolve, reject) => {
                (0, https_1.get)(componentsJsonUrl, (res) => {
                    const buff = [];
                    res.on('data', (chunk) => buff.push(chunk));
                    res.on('end', () => {
                        const body = Buffer.concat(buff).toString();
                        if (res.statusCode !== 200) {
                            reject(new error_1.default('Unable fetch the component map', {
                                context: body
                            }));
                        }
                        resolve(JSON.parse(body));
                    });
                }).on('error', (er) => reject(er));
            })
            : yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const infoFilePath = (0, path_1.join)(constants_1.LOCAL_COMPONENTS_PATH, constants_1.PATHS.info);
                    const infoFileStr = yield (0, promises_1.readFile)(infoFilePath);
                    resolve(JSON.parse(infoFileStr.toString()));
                }
                catch (er) {
                    if (er instanceof Error) {
                        const _er = er;
                        if (_er.code === 'ENOENT') {
                            // // if file not found populate data from remote
                            // await this.#getData('remote');
                            return resolve();
                        }
                    }
                    reject(er);
                }
            }));
        if (!mapJson) {
            // return in case if the mapJson is empty so prevents overwriting with empty values,
            // works with cases where info.json not found in local
            return;
        }
        this.rootFs = mapJson.root_fs;
        this.lang = mapJson.lang;
        this.runtime = mapJson.runtime;
    });
};
/**
 * Utility class that contains the static map of Catalyst container component details present in local and remote
 */
class ComponentMap {
}
exports.ComponentMap = ComponentMap;
/** Details of the Catalyst container components present in local */
ComponentMap.local = new ContainerComponents('local');
/** Details of the Catalyst container components present in local */
ComponentMap.remote = new ContainerComponents('remote');
