"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LOG_LEVELS = void 0;
const stream_1 = require("stream");
const error_1 = __importDefault(require("./error"));
const ansi_colors_1 = require("ansi-colors");
/** Log levels of the plugin logger */
var LOG_LEVELS;
(function (LOG_LEVELS) {
    LOG_LEVELS[LOG_LEVELS["error"] = 0] = "error";
    LOG_LEVELS[LOG_LEVELS["warn"] = 1] = "warn";
    LOG_LEVELS[LOG_LEVELS["info"] = 2] = "info";
    LOG_LEVELS[LOG_LEVELS["debug"] = 3] = "debug";
})(LOG_LEVELS || (exports.LOG_LEVELS = LOG_LEVELS = {}));
const prefixLabel = {
    [LOG_LEVELS.info]: `${ansi_colors_1.bold.cyan('[ INFO  ]')} :::`,
    [LOG_LEVELS.debug]: `${ansi_colors_1.bold.magenta('[ DEBUG ]')} :::`,
    [LOG_LEVELS.warn]: `${ansi_colors_1.bold.yellow('[ WARN  ]')} :::`,
    [LOG_LEVELS.error]: `${ansi_colors_1.bold.red('[ ERROR ]')} :::`
};
// Get the log level from the environment variable (default to 'info')
const currentLogLevel = process.env.ZC_LOG_LVL || 'info';
const logLevelThreshold = (_a = LOG_LEVELS[currentLogLevel]) !== null && _a !== void 0 ? _a : LOG_LEVELS.info;
class Logger {
    /**
     * Create a new Logger instance
     * @param stdout stream to write stdout messages
     * @param stderr stream to write stderr messages
     */
    constructor(stdout, stderr) {
        if (!(stdout instanceof stream_1.Writable) || !(stderr instanceof stream_1.Writable)) {
            throw new error_1.default('stdout and stderr must be writable streams');
        }
        this.stdout = stdout;
        this.stderr = stderr;
    }
    /** log message to the stdout or stderr streams based on the LOG_LEVELS
     * @param level specify the log level
     * @param message message to be written to the stream
     *
     * @returns boolean which indicates the success of data written to the stream
     */
    log(level, message) {
        message = `${prefixLabel[level]} ${message}`;
        if (level <= logLevelThreshold) {
            if (level === LOG_LEVELS.error || level === LOG_LEVELS.warn) {
                return this.stderr.writable && this.stderr.write(message + '\n');
            }
            return this.stdout.writable && this.stdout.write(message + '\n');
        }
        return false;
    }
    /** wite error message to stderr
     * @param message message to be written
     * @return
     */
    error(message) {
        return this.log(LOG_LEVELS.error, message);
    }
    /** write warning message to stderr
     * @param message message to be written
     * @return
     */
    warn(message) {
        return this.log(LOG_LEVELS.warn, message);
    }
    /** write info message to stdout
     * @param message message to be written
     * @return
     */
    info(message = '') {
        return this.log(LOG_LEVELS.info, message);
    }
    /** write debug message to stdout
     * @param message message to be written
     * @return
     */
    debug(message) {
        return this.log(LOG_LEVELS.debug, message);
    }
}
/** Logger instance */
exports.default = new Logger(process.stdout, process.stderr);
