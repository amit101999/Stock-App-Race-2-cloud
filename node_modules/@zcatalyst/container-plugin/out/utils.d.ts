import { EventEmitter, Readable } from 'stream';
import { IncomingMessage } from 'http';
import { SimpleLock } from './components/lock';
/**
 * Class that's used to communicate the container events
 */
export declare class ContainerEvents extends EventEmitter {
    stdout: Readable;
    stderr: Readable;
    constructor(stdout: Readable, stderr: Readable);
}
export declare const EventsLock: SimpleLock;
/**
 * Synchronously Check if the path is a directory
 * @param path path to be checked
 * @param alwaysResolve flag to set whether to resolve or reject by throwing error
 * @returns A boolean stating whether the path is a directory
 */
export declare function isDirSync(path: string, alwaysResolve?: boolean): boolean;
/**
 * Asynchronously Check if the path is a directory
 * @param path path to be checked
 * @param alwaysResolve flag to set whether to resolve or reject by throwing error
 * @returns Promise that resolves to a boolean stating whether the path is a directory
 */
export declare function isDir(path: string, alwaysResolve?: boolean): Promise<boolean>;
/**
 * Introduces a pause or timeout in the execution
 * @param ms time in ms for which the execution should be paused
 * @returns Promise that always resolves when the timeout is reached
 */
export declare function sleep(ms: number): Promise<void>;
/**
 * Ensures a directory is present in the path
 * @param path path to the directory
 */
export declare function ensureDir(path: string): Promise<void>;
/**
 * Deletes a path in the filesystem
 * behaves like rm -rf <path>
 * @param path path to delete
 * @returns
 */
export declare function deletePath(path: string): Promise<void>;
/**
 * Supported Catalyst Http Functions
 */
export declare const httpFns: string[];
/**
 * Get the startup command based on the function
 * @param param0
 * @returns
 */
export declare const getFnCommand: ({ stack, fnType, debug, maxMem, minMem }: {
    /** stack or language */
    stack: string;
    /** type of the function */
    fnType: string;
    /** is debug enabled */
    debug: boolean;
    /** maximum process memory */
    maxMem: string;
    /** minimum process memory */
    minMem: string;
}) => Array<string>;
/**
 * Get the response as stream by making a `GET` request to the provided url
 * @param url to GET
 * @param logProgress label to add to the progress throbber
 * @returns Promise that resolves to the {@link IncomingMessage} which is a type of Readable Stream
 * if the response to the GET request is 200
 */
export declare function getAsStream(url: string, logProgress?: string): Promise<IncomingMessage>;
