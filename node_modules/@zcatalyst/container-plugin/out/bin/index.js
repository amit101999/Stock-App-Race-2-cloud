#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = __importDefault(require("fs/promises"));
const ansi_colors_1 = require("ansi-colors");
const error_1 = __importDefault(require("../error"));
const component_map_1 = require("../components/component-map");
const image_1 = require("../endpoints/image");
const logger_1 = __importDefault(require("../logger"));
const util_1 = require("util");
const components_1 = require("../components");
const constants_1 = require("../constants");
const commands = {
    'component:ensure': {
        structure: 'component ensure',
        description: 'Ensure the components required to serve a Catalyst component within container in local machine',
        options: {
            '--root-fs': 'the base runtime image',
            '--runtime': 'the runtime for functions and appsail',
            '--lang-bin': 'language binaries specific to the stack'
        }
    },
    'component:delete': {
        structure: 'component delete',
        description: 'Clear the container components for a component in local machine',
        options: {
            '--root-fs': 'the base runtime image',
            '--runtime': 'the runtime for functions and appsail',
            '--lang-bin': 'language binaries specific to the stack',
            '--all': 'This option will completely reset the container components in local machine'
        }
    },
    help: {
        structure: 'help [command]',
        description: 'get help for a command',
        args: {
            command: 'The command to get help for'
        }
    }
};
function printFullHelp() {
    logger_1.default.info(ansi_colors_1.bold.cyan('@ZCATALYST/CONTAINER-PLUGIN HELP'));
    logger_1.default.info();
    logger_1.default.info((0, ansi_colors_1.bold)('Commands:'));
    logger_1.default.info();
    let maxLen = 0;
    Object.keys(commands).forEach((cmd) => {
        if (cmd.length > maxLen) {
            maxLen = cmd.length;
        }
    });
    Object.keys(commands).forEach((cmd) => {
        const _cmd = commands[cmd];
        const fill = maxLen - cmd.length + 1;
        logger_1.default.info(`${(0, ansi_colors_1.underline)(cmd) + ' '.repeat(fill)} -> ${_cmd.description}`);
    });
    logger_1.default.info();
}
function printCommandHelp(command) {
    logger_1.default.info(ansi_colors_1.bold.cyan('@ZCATALYST/CONTAINER-PLUGIN HELP'));
    const _cmd = commands[command];
    if (!_cmd) {
        logger_1.default.info(`${(0, ansi_colors_1.red)('Error')}: Unknown command')`);
        return;
    }
    logger_1.default.info(`\n${(0, ansi_colors_1.bold)('Command:')} ${command}`);
    logger_1.default.info(`\n${(0, ansi_colors_1.bold)('Description:')}`);
    logger_1.default.info(`   ${_cmd.description}`);
    if (_cmd.args) {
        logger_1.default.info(`\n${(0, ansi_colors_1.bold)('Args:')}`);
        let maxLen = 0;
        Object.keys(_cmd.args).forEach((arg) => {
            maxLen = arg.length > maxLen ? arg.length : maxLen;
        });
        Object.keys(_cmd.args).forEach((arg) => {
            const fill = maxLen - arg.length + 1;
            logger_1.default.info(`   ${arg + ' '.repeat(fill)}: ${_cmd.args ? _cmd.args[arg] : 'unknown'}`);
        });
    }
    if (_cmd.options) {
        logger_1.default.info(`\n${(0, ansi_colors_1.bold)('Options:')}`);
        let maxLen = 0;
        Object.keys(_cmd.options).forEach((opt) => {
            maxLen = opt.length > maxLen ? opt.length : maxLen;
        });
        Object.keys(_cmd.options).forEach((opt) => {
            const fill = maxLen - opt.length + 1;
            logger_1.default.info(`   ${opt + ' '.repeat(fill)}: ${_cmd.options ? _cmd.options[opt] : 'unknown'}`);
        });
    }
}
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        const args = process.argv.slice(2);
        const command = args.shift();
        switch (command) {
            case 'help': {
                const _cmd = args.shift();
                if (!_cmd) {
                    logger_1.default.error('Unable to find the command. Please find the list of commands below.');
                    printFullHelp();
                    process.exit(1);
                }
                printCommandHelp(_cmd);
                break;
            }
            case 'component:ensure': {
                let rootFs, lang, runtime;
                while (process.argv) {
                    const arg = process.argv.shift();
                    switch (arg) {
                        case '--rootFs': {
                            rootFs = process.argv.shift();
                            break;
                        }
                        case '--lang-bin': {
                            lang = process.argv.shift();
                            break;
                        }
                        case '--runtime': {
                            runtime = process.argv.shift();
                            break;
                        }
                        default: {
                            throw new error_1.default('Invalid option for command component:ensure', { context: process.argv });
                        }
                    }
                }
                yield (0, components_1.ensureComponents)({ rootFs, lang, runtime });
                break;
            }
            case 'component:delete': {
                let rootFs, lang, runtime, all;
                while (process.argv) {
                    const arg = process.argv.shift();
                    switch (arg) {
                        case '--rootFs': {
                            rootFs = process.argv.shift();
                            rootFs = (0, component_map_1.getRootFsName)(rootFs);
                            break;
                        }
                        case '--lang-bin': {
                            lang = process.argv.shift();
                            break;
                        }
                        case '--runtime': {
                            runtime = process.argv.shift();
                            break;
                        }
                        case '--all': {
                            all = true;
                            break;
                        }
                        default: {
                            throw new error_1.default('Invalid option for command component:ensure', { context: process.argv });
                        }
                    }
                }
                if (all) {
                    yield (0, image_1.removeImages)('localhost/zcatalyst/');
                    const componentsRoot = constants_1.LOCAL_COMPONENTS_PATH;
                    yield promises_1.default.rmdir(componentsRoot);
                    logger_1.default.info((0, ansi_colors_1.green)('Removed all container components form local machine'));
                    return;
                }
                if (rootFs) {
                    yield (0, image_1.removeImages)(rootFs);
                    logger_1.default.info((0, ansi_colors_1.green)('Removed rootFs'));
                }
                if (lang) {
                    const langPath = (0, components_1.getLocalComponentPath)(lang).lang;
                    yield promises_1.default.rmdir(langPath);
                    logger_1.default.info((0, ansi_colors_1.green)('Removed lang-bin'));
                }
                if (runtime) {
                    const runtimePath = (0, components_1.getLocalComponentPath)(runtime).runtime;
                    yield promises_1.default.rmdir(runtimePath);
                    logger_1.default.info((0, ansi_colors_1.green)('Removed runtime'));
                }
                break;
            }
            default: {
                logger_1.default.error('Unknown command: The supported commands are\n');
                printFullHelp();
                process.exit(1);
            }
        }
    });
}
main()
    .then(() => process.exit(0))
    .catch((er) => {
    logger_1.default.error('Error when executing the command');
    logger_1.default.error((0, util_1.inspect)(er));
    process.exit(1);
});
