"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFnCommand = exports.httpFns = exports.EventsLock = exports.ContainerEvents = void 0;
exports.isDirSync = isDirSync;
exports.isDir = isDir;
exports.sleep = sleep;
exports.ensureDir = ensureDir;
exports.deletePath = deletePath;
exports.getAsStream = getAsStream;
const promises_1 = require("fs/promises");
const error_1 = __importDefault(require("./error"));
const stream_1 = require("stream");
const fs_1 = require("fs");
const https_1 = require("https");
const logger_1 = __importDefault(require("./logger"));
const progress_1 = __importDefault(require("@zcatalyst/cli-utils/out/progress"));
const ansi_colors_1 = require("ansi-colors");
const lock_1 = require("./components/lock");
/**
 * Class that's used to communicate the container events
 */
class ContainerEvents extends stream_1.EventEmitter {
    constructor(stdout, stderr) {
        super();
        this.stdout = stdout;
        this.stderr = stderr;
    }
}
exports.ContainerEvents = ContainerEvents;
exports.EventsLock = new lock_1.SimpleLock();
/**
 * Synchronously Check if the path is a directory
 * @param path path to be checked
 * @param alwaysResolve flag to set whether to resolve or reject by throwing error
 * @returns A boolean stating whether the path is a directory
 */
function isDirSync(path, alwaysResolve = true) {
    try {
        const dirStat = (0, fs_1.statSync)(path);
        return dirStat.isDirectory();
    }
    catch (er) {
        if (er instanceof Error && er.code === 'ENOENT') {
            return false;
        }
        if (!alwaysResolve) {
            throw er;
        }
        return false;
    }
}
/**
 * Asynchronously Check if the path is a directory
 * @param path path to be checked
 * @param alwaysResolve flag to set whether to resolve or reject by throwing error
 * @returns Promise that resolves to a boolean stating whether the path is a directory
 */
function isDir(path_1) {
    return __awaiter(this, arguments, void 0, function* (path, alwaysResolve = true) {
        try {
            const dirStat = yield (0, promises_1.stat)(path);
            return dirStat.isDirectory();
        }
        catch (er) {
            if (er instanceof Error && er.code === 'ENOENT') {
                return false;
            }
            if (!alwaysResolve) {
                throw er;
            }
            return false;
        }
    });
}
/**
 * Introduces a pause or timeout in the execution
 * @param ms time in ms for which the execution should be paused
 * @returns Promise that always resolves when the timeout is reached
 */
function sleep(ms) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
            setTimeout(resolve, ms);
        });
    });
}
/**
 * Ensures a directory is present in the path
 * @param path path to the directory
 */
function ensureDir(path) {
    return __awaiter(this, void 0, void 0, function* () {
        const dir = yield isDir(path);
        !dir && (yield (0, promises_1.mkdir)(path, { recursive: true }));
    });
}
/**
 * Deletes a path in the filesystem
 * behaves like rm -rf <path>
 * @param path path to delete
 * @returns
 */
function deletePath(path) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0, promises_1.rm)(path, { force: true, recursive: true, retryDelay: 300 });
    });
}
/**
 * Supported Catalyst Http Functions
 */
exports.httpFns = ['aio', 'bio', 'browser_logic'];
/**
 * Get the startup command based on the function
 * @param param0
 * @returns
 */
const getFnCommand = ({ stack, fnType, debug = false, maxMem, minMem }) => {
    const lang = stack.match(/^([a-zA-Z]+)([0-9_]+)$/); // sample str "node20"
    switch (lang === null || lang === void 0 ? void 0 : lang.at(1)) {
        case 'node': {
            const command = [
                '/var/lang/bin/node',
                '--stack-trace-limit=100',
                '--max-semi-space-size=' + minMem,
                '--max-old-space-size=' + maxMem,
                '/var/runtime/index.js'
            ];
            if (debug) {
                const debugOpt = exports.httpFns.includes(fnType)
                    ? '--inspect=0.0.0.0:9100'
                    : '--inspect-brk=0.0.0.0:9100';
                command.splice(1, 0, debugOpt);
            }
            return command;
        }
        case 'java': {
            const command = [
                '/var/lang/bin/java',
                '-XX:+HeapDumpOnOutOfMemoryError',
                `-Xmx${maxMem}M`,
                `-Xms${minMem}M`,
                `-cp`,
                '/var/runtime/*',
                fnType === 'job'
                    ? 'com.cop.main.server.SchedulingJobFlow'
                    : 'com.cop.main.server.DefaultCoreServer',
                '>>',
                '/tmp/serverOut.log',
                '2&1'
            ];
            if (stack === 'java8') {
                command.splice(1, 0, '-XX:+UseConcMarkSweepGC');
            }
            if (debug) {
                const debugOpt = '-agentlib:jdwp=transport=dt_socket,server=y,address=0.0.0.0:9100,suspend=' +
                    (exports.httpFns.includes(fnType) ? 'n' : 'y');
                command.splice(1, 0, debugOpt);
            }
            return command;
        }
        case 'python': {
            return ['/var/lang/bin/python3', '-u', '/var/runtime/main.py'];
        }
        default: {
            throw new error_1.default('Unable to retrieve the command for function of lang ' + lang, { context: { stack, fnType, debug } });
        }
    }
};
exports.getFnCommand = getFnCommand;
// function toMB(byteLength: bigint): number {
// 	const MB = 1024n * 1024n;
// 	return Number(byteLength / MB);
// }
// function consoleOverWrite(text: string) {
// 	process.stdout.clearLine(0);
// 	process.stdout.cursorTo(0);
// 	process.stdout.write(text);
// }
/**
 * Get the response as stream by making a `GET` request to the provided url
 * @param url to GET
 * @param logProgress label to add to the progress throbber
 * @returns Promise that resolves to the {@link IncomingMessage} which is a type of Readable Stream
 * if the response to the GET request is 200
 */
function getAsStream(url, logProgress) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield new Promise((resolve, reject) => {
            (0, https_1.get)(url, (response) => {
                if (response.statusCode === 200) {
                    response.pause();
                    resolve(response);
                    return;
                }
                const buff = [];
                response.on('data', (ch) => buff.push(ch));
                response.on('end', () => {
                    reject(new error_1.default('Error when trying to download from url :: ' + url, {
                        context: {
                            status: response.statusCode,
                            data: Buffer.concat(buff).toString()
                        }
                    }));
                });
            }).on('error', (er) => reject(new error_1.default('Error when communicating with server to download from url: ' + url, {
                original: er
            })));
        });
        if (res.destroyed) {
            throw new error_1.default('Download stream destroyed before consumption');
        }
        if (logProgress) {
            // const downloadSize = toMB(BigInt(Number.parseInt(res.headers['content-length'] || '0')));
            const downloadSize = Number.parseInt(res.headers['content-length'] || '0');
            if (downloadSize === 0) {
                throw new error_1.default('Invalid download size ', { context: downloadSize });
            }
            logger_1.default.debug('Total content length: ' + downloadSize + ' MB');
            const downloadProgress = new progress_1.default({
                total: downloadSize,
                title: logProgress,
                failure: (err) => (0, ansi_colors_1.red)(`Download failure with error: ` + (err instanceof Error ? err.message : err) ||
                    'Unknown error')
            });
            // let downloadedLength = 0;
            res.on('data', (ch) => {
                downloadProgress.tick(ch.length);
                // downloadedLength += ch.length;
                // consoleOverWrite(
                // 	`Downloaded: ${toMB(BigInt(downloadedLength)).toString()} MB/${downloadSize.toString()} MB`
                // );
            });
            res.on('error', (err) => downloadProgress.error(err));
        }
        return res;
    });
}
