"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = start;
const stream_1 = require("stream");
const container_1 = require("./endpoints/container");
const utils_1 = require("./utils");
const http_1 = require("http");
const error_1 = __importDefault(require("./error"));
const prepare_1 = __importDefault(require("./prepare"));
const logger_1 = __importDefault(require("./logger"));
const util = __importStar(require("util"));
/**
 * start the catalyst function/appsail in a container
 * @param param0 details of the functions/appsail
 * @returns Promise that resolves to an event emitter
 */
function start(_a) {
    return __awaiter(this, arguments, void 0, function* ({ details, projectId, ruok = container_1.RUOK.FINITE }) {
        const targetDetails = details; // TODO: Unsave type conversion. Fix this.
        const out = new stream_1.PassThrough();
        const err = new stream_1.PassThrough();
        const pluginEvents = new utils_1.ContainerEvents(out, err);
        const attachStreams = [];
        const contStreamDestroyer = (attachRes) => () => {
            if (!(attachRes instanceof http_1.IncomingMessage)) {
                return;
            }
            // going for timeout based approach since, the 'end' event is not getting emitted and handling with it not possible.
            // need to find a better approach than timeout.
            attachRes.complete ? attachRes.destroy() : setTimeout(() => attachRes.destroy(), 1000); // 1s timeout before destroying the container log stream.
        };
        try {
            /** Creating new container */
            if (!targetDetails.target) {
                throw new error_1.default('Invalid fn target: ' + targetDetails.target);
            }
            // run container
            const containerOpts = yield (0, prepare_1.default)(targetDetails, projectId);
            const container = yield (0, container_1.createServerContainer)(containerOpts);
            if (!container) {
                throw new error_1.default('Invalid container object', { context: container + '' });
            }
            // pluginEvents.on('error', (er) => {
            // 	LOGGER.error('Plugin Serve Error: ' + er);
            // 	container.stop();
            // 	container.remove();
            // });
            /** Running the container */
            // start the container
            pluginEvents.once('start', (target) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                const lockName = `${(_a = target.target) === null || _a === void 0 ? void 0 : _a.name}_start`;
                if (!utils_1.EventsLock.getLock(lockName)) {
                    yield utils_1.EventsLock.waitRelease(lockName);
                    return;
                }
                try {
                    // attach log stream
                    const attachRes = yield container.attach({
                        stream: true,
                        stdout: true,
                        stderr: true
                    });
                    attachStreams.push(attachRes);
                    container.modem.demuxStream(attachRes, out, err);
                    pluginEvents.once('close', contStreamDestroyer(attachRes));
                    // start the container
                    yield container.start();
                    if (target.type === 'functions' || target.type === 'server') {
                        switch (ruok) {
                            case container_1.RUOK.FINITE: {
                                yield (0, container_1.ruok)(target);
                                break;
                            }
                            case container_1.RUOK.INFINITE: {
                                yield (0, container_1.ruok)(target, Infinity); // TODO: introduce exponential backoff with a limit
                                break;
                            }
                            case container_1.RUOK.SKIP: {
                                break;
                            }
                            default: {
                                throw new error_1.default('Invalid Ruok config');
                            }
                        }
                    }
                    else {
                        // for other components, if the container process is not started within 200ms throw error
                        yield new Promise((resolve) => setTimeout(resolve, 200));
                        const containerInfo = yield container.inspect();
                        if (!containerInfo.State.Running) {
                            throw new error_1.default('Container process did not start properly. Exit Code: ' +
                                containerInfo.State.ExitCode);
                        }
                    }
                    pluginEvents.emit('ready');
                    logger_1.default.debug(`Running container with Id: ${container.id.slice(0, 11)}`);
                }
                catch (er) {
                    logger_1.default.error('Error starting the container for function: ' + ((_b = target.target) === null || _b === void 0 ? void 0 : _b.name));
                    er instanceof Error && logger_1.default.error(er.toString());
                    logger_1.default.debug('Error: ' + util.inspect(er));
                    pluginEvents.emit('error', er);
                }
                finally {
                    utils_1.EventsLock.releaseLock(lockName);
                }
            }));
            targetDetails.type !== 'appsail' &&
                pluginEvents.on('preparing', (target) => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b, _c, _d, _e;
                    const startLock = `${(_a = target.target) === null || _a === void 0 ? void 0 : _a.name}_ start`;
                    utils_1.EventsLock.releaseLock(startLock); // releasing the lock if any
                    const lockName = `${(_b = target.target) === null || _b === void 0 ? void 0 : _b.name}_preparing`;
                    if (!utils_1.EventsLock.getLock(lockName)) {
                        yield utils_1.EventsLock.waitRelease(lockName);
                        return;
                    }
                    try {
                        if (target.target && target.target.name !== ((_c = targetDetails.target) === null || _c === void 0 ? void 0 : _c.name)) {
                            return;
                        }
                        const contInspect = yield container.inspect().catch((er) => {
                            if (er.statusCode !== 404) {
                                throw er instanceof Error
                                    ? er
                                    : new error_1.default('Error getting the container info', {
                                        original: er
                                    });
                            }
                        });
                        if (!contInspect || !contInspect.State.Running) {
                            logger_1.default.debug('Container not running when preparing for fn: ' + ((_d = target.target) === null || _d === void 0 ? void 0 : _d.name));
                            return;
                        }
                        yield container.stop().catch((er) => {
                            if (er.statusCode !== 304) {
                                throw er instanceof Error
                                    ? er
                                    : new error_1.default('Error stopping the container', {
                                        original: er
                                    });
                            }
                        });
                        logger_1.default.debug(`Stopped container with Id for preparing: ${container.id.slice(0, 11)}`);
                    }
                    catch (er) {
                        logger_1.default.error('Error when handling the prepare event for function: ' + ((_e = target.target) === null || _e === void 0 ? void 0 : _e.name));
                        logger_1.default.debug('Error: ' + (er === null || er === void 0 ? void 0 : er.toString()));
                        pluginEvents.emit('error', er);
                    }
                    finally {
                        utils_1.EventsLock.releaseLock(lockName);
                    }
                }));
            // bind restart container
            targetDetails.type !== 'appsail' &&
                pluginEvents.on('restart', (target) => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b, _c, _d;
                    // wait till preparing is completed
                    const preparingLockName = `${(_a = target.target) === null || _a === void 0 ? void 0 : _a.name}_preparing`;
                    yield utils_1.EventsLock.waitRelease(preparingLockName);
                    // restart the function
                    const lockName = `${(_b = target.target) === null || _b === void 0 ? void 0 : _b.name}_restart`;
                    if (!utils_1.EventsLock.getLock(lockName)) {
                        // await previous restart // TODO: evaluate should this event be skipped and the server should be killed and started again
                        yield utils_1.EventsLock.waitRelease(lockName);
                        return;
                    }
                    try {
                        if (target.target && target.target.name !== ((_c = targetDetails.target) === null || _c === void 0 ? void 0 : _c.name)) {
                            return;
                        }
                        const contStatus = (yield container.inspect()).State.Status;
                        if (contStatus !== 'exited' && contStatus !== 'dead') {
                            return;
                        }
                        yield container.start();
                        const attachRes = yield container.attach({
                            stream: true,
                            stdout: true,
                            stderr: true
                        });
                        attachStreams.push(attachRes);
                        container.modem.demuxStream(attachRes, process.stdout, process.stderr);
                        try {
                            switch (ruok) {
                                case container_1.RUOK.FINITE: {
                                    yield (0, container_1.ruok)(target);
                                    break;
                                }
                                case container_1.RUOK.INFINITE: {
                                    yield (0, container_1.ruok)(target, -1); // TODO: introduce exponential backoff with a limit
                                    break;
                                }
                                case container_1.RUOK.SKIP: {
                                    break;
                                }
                                default: {
                                    throw new error_1.default('Invalid Ruok config');
                                }
                            }
                        }
                        catch (er) {
                            if (er instanceof error_1.default) {
                                logger_1.default.debug('Ruok Error during restart');
                                return;
                            }
                            throw er;
                        }
                        pluginEvents.emit('ready');
                        logger_1.default.debug(`Restarted container with Id: ${container.id.slice(0, 11)}`);
                    }
                    catch (er) {
                        logger_1.default.error('Error restarting the container for function: ' + ((_d = target.target) === null || _d === void 0 ? void 0 : _d.name));
                        pluginEvents.emit('error', er);
                    }
                    finally {
                        utils_1.EventsLock.releaseLock(lockName);
                    }
                }));
            /** Stopping the container and cleanup */
            pluginEvents.on('close', (target) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                const startLockName = `${(_a = target.target) === null || _a === void 0 ? void 0 : _a.name}_start`;
                utils_1.EventsLock.releaseLock(startLockName);
                const preparingLockName = `${(_b = target.target) === null || _b === void 0 ? void 0 : _b.name}_preparing`;
                utils_1.EventsLock.releaseLock(preparingLockName);
                const restartLockName = `${(_c = target.target) === null || _c === void 0 ? void 0 : _c.name}_restart`;
                utils_1.EventsLock.releaseLock(restartLockName);
                const lockName = `${(_d = target.target) === null || _d === void 0 ? void 0 : _d.name}_close`;
                if (!utils_1.EventsLock.getLock(lockName)) {
                    yield utils_1.EventsLock.waitRelease(lockName);
                    return;
                }
                try {
                    if (((_e = target.target) === null || _e === void 0 ? void 0 : _e.name) !== ((_f = targetDetails.target) === null || _f === void 0 ? void 0 : _f.name)) {
                        return;
                    }
                    attachStreams.forEach((stream) => {
                        if (!(stream instanceof http_1.IncomingMessage)) {
                            return;
                        }
                        // going for timeout based approach since, the 'end' event is not getting emitted and handling with it not possible.
                        // need to find a better approach than timeout.
                        stream.complete
                            ? stream.destroy()
                            : setTimeout(() => stream.destroy(), 1000); // 1s timeout before destroying the container log stream.
                    });
                    const { inspect, statusCode, error } = yield (0, container_1.stopContainer)(container);
                    if (error) {
                        const _err = error;
                        if (!((_g = _err.Message) === null || _g === void 0 ? void 0 : _g.includes('no container with ID'))) {
                            // excluding no container found error.
                            pluginEvents.emit('error', new error_1.default('Container exited with an error', {
                                original: error
                            }));
                        }
                    }
                    pluginEvents.emit('exit', statusCode || 0);
                    logger_1.default.debug('Closing ::: container details on exit: ' + util.inspect(inspect));
                    logger_1.default.debug('Closing ::: trying to remove container with Id: ' + container.id);
                    yield container.remove().catch((err) => {
                        if (err.statusCode !== 404) {
                            throw err;
                        }
                        logger_1.default.debug(`Closing ::: Error removing the container ::: ${err.message}`);
                    });
                }
                catch (er) {
                    logger_1.default.error('Error closing the container for function: ' + ((_h = target.target) === null || _h === void 0 ? void 0 : _h.name));
                    pluginEvents.emit('error', er);
                }
                finally {
                    utils_1.EventsLock.releaseLock(lockName);
                }
            }));
            return pluginEvents;
        }
        catch (er) {
            pluginEvents.emit('error', er);
            throw er;
        }
    });
}
